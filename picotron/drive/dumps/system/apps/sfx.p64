picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIyIDA3OjMwOjA0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAxNjo1ODo1NiIscmV2aXNpb249MTIxMDMsc3RvcmVkPSIyMDIzLTM2LTI5IDA0OjM2OjQw
Il1dbHo0APAFAACbNgAA8Qp7WzBdPXtibXA9cHh1AEMgBQUEIAcwBwBHBgDxASxmbGFncz0wLHBh
bl94PTYIANp5PS00LHpvb209OH0sOwBXJwAXAAcEAB8nQQAdvwcANzAHIAcwNwAHOwAdMBAHIH8A
TycgB0A7AB9-MAeABzAHEDkAGlsQEATw8DIAEzAyAB8wMQAFcBEXEBcgJ0DkAPADFzAnEBcQJ-AE
BwAHEBcQB1AnwwD-AFAHABcgJ-AEJ_AH4AfwLGAAGSAgEIEBAFQAEQBTADIAByAKAPEDByAHIBcA
JxAHECcgBwAnACcQKAEgABcQAD-w-5LFAB0f8DEA-w9SBAQEABfXAT8AFwA6ABmxBQUEACcAByAX
IBesAQ88ABw-oCegMgAcf1AnECcQJ1A2ABxAYAcgB1wCDm4DDzoADS-wCTEArP8DCAgEsA8QUC4w
LjAOAA5AHvAFbwAcATkBMUBHQAgADzwAHTEwBzDTAwNkBQ9AAB0hIBcOBABHAA96AB0gIGdwAAA5
BB8QkQF7VMhkBPD-AQDwEHFR8LFx8K_R8AMh8JbB8AFB8JTh8ABB8D8x8EBxEFELAII_UfA_cTBR
4AoAIGFACgDAPWHwISHwCVFwUcBRDQBRIEHwB2ENAPAKPGHwIUHwBmGQQcBB8Cch8ANh8CBR8AZR
oBAAUSZB8AFxEAAiQbAQACDggQ8AsAdBsEGwUfAmQdCRDwAwCCHADwAgJVEPALFB8BlBsEHwJlHA
oQ0AgFGgQfAlYcCRZwCQGVGQUfAlYbChNgAgGkENACRRwA0AADQAILCxNAAaGw0AEIA0AGSgUQBB
8CEPACBRsA8AADgAEVEPADSgURAPAAA6AHKgUQBR8B9RSQBEJWGQYQ8AAC0AR2GQURA8AEFhgFEg
WgABPAAkJXEPACAZUTwAR3FwUTAPACBhgA8AQhkhUCHZALckcXBRQEHwGEHwIQ8A8BcXUfAgUbBB
8AmB8AJxYFFQQfAWYfAf8RLAsfABcVBhUEHQIUCBUBMA8AcUkOHggVBRYEHA8QMAkfAg8RSA8QDg
JADAUbDxDvAh8RRw8QHQIgDwElGg8Q7wIvETcIEwQdCBQFFwQbDxDfAiUdBR8AJhMGHAkRMAEKAT
APAQYdBB8ANBMIHAkTBRgEGQYRDxAfAlYeBB8AJREJHAoRUAYYBxQKHwKC4C1QLxAsChIFGQQWCB
oFEUAFABwFEAQRYAcDCxoFHwJ1FpAkAC0fAAFgCSQaBBENGgQfAoFgDCwfAAURBBEFGgQQDRLABy
AkHwApHwAxYAofEEoFHwByHwDGEYAMBx8ARRIEEAUbDxBJBIAvEG8Aph8ANR8AFhsDFAUSCxwKEg
QWCBGABwUfAEUfACcXEBsDCh4GFQQUCR8AdRGADwCAVB8AOBYFEgUTCh8ABBYEEgsfAGYfAJtgLA
8APxBRBhMJHwDfEDLgAgCWEVAGAE8QMQYUAVABABJwDzBAlR8AhB8AXxASBRUJHwDtHwC0EXADAG
0TB-AHEQkfAPIfAJVADxJwihUCGAUfATYfAscfAKQfCRYfALUfCQUfAMUfCRMfAOUfCyUfCzUfCy
YfCycfCwgfCwcfCxYRUAOjHw-wEAH2X3AwseMigED-cHHg8xAP91EzI_CJMAB1AHECcAJ0BbBiDw
BQkAgxcQB3AHIAcQFwBPACfwQ0IGSjAICASAC28wRyBH8BM5AByfRyBHMCdQB-AVNAEeDzEArMAH
BwSQDUANMB0QDWACAA88AB2AB0AHMBcQB2ACAA-aAB4PMQD-D2MHBwQgFzBbDgQEAAAQAC9AF78J
DCwxNkkA8QAOEB0ADgAODQANDgAdDgAPACANEAoAEiAVAAESAA9WAB1jkAdQFxBXoQAvB5A-AB0i
gAfUAH8AVxAXUAegPwAdM3BHEAIAH3A7AA0PugEv-wM0F9A3sFeQd3B3cFeQN7AX8DpCAB4pd3AC
AC-wND4CHg8xAP-----------------------------------------------7xQbT04fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA5IDAyOjM2OjAxIixtb2RpZmllZD0iMjAyNS0w
My0zMSAxOToyMzowNiIscmV2aXNpb249MF1d
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIyIDA3OjMwOjA0Iixtb2RpZmllZD0iMjAyNC0w
OS0xMiAxNjo1ODo1NiIscmV2aXNpb249OTAxNyxzdG9yZWQ9IjIwMjMtMzYtMjkgMDQ6MzY6NDAi
XV1sejQAcAAAAF8QAADwCHt7Ym1wPXVzZXJkYXRhKCJpMTYiLDMyAwAvIjABAP--------------
------vxESIpLGhpZGRlbj1mYWxzZSxuYW1lPSJmIixwYW5feD0wCADCeT0wLHRpbGVfaD01CQDA
dz01LHpvb209MX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA5IDAyOjM2OjAxIixtb2RpZmllZD0iMjAyNS0w
My0zMSAxOToyMzowNiIscmV2aXNpb249MF1d
:: amp.lua
--[[pod_format="raw",created="2023-29-17 13:29:48",revision=257,stored="2023-27-19 23:27:17"]]
-- amp filter










































































:: data.lua
--[[pod_format="raw",created="2023-10-24 00:36:58",modified="2024-09-12 16:58:56",revision=11004,stored="2023-36-29 04:36:40"]]

function init_track(addr)
--	printh("init_track "..addr)
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- fx, fx_p: clear
	memset(addr+8+64*3, 0x0, 64*2)
end

function clear_pattern(i)
	local addr = 0x30100 + i*20
	memset(addr,0,20)
end

function clear_instrument(i)
	local addr = 0x40000 + i * 0x200
	
	memset(addr, 0, 0x200)
	
	-- node 0: root
	poke(addr + (0 * 32), -- node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(addr + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	
	-- wavetables
	poke(addr + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- white noise
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)

	-- envelope 0 inst 1
	
	poke(addr + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
end


function init_data()

	-- use 256k from 0x30000
	-- gives 399 SFX and managemable size for undo state comparisons
	-- if change this need, to adjust undo stack size and loader/saver
	
	memset(0x30000, 0, 0x40000)
	

	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 16 patterns
	-- want to keep default sfx file quite tiny
	-- .. should be ok to save a whole .sfx for just one inst / experiment
	-- later: interface to generate more default patterns
	
	for pp = 0,3
	do
		local addr = 0x30100 + pp * 20
		for i = 0, 3 do
			poke(addr+i, pp*4 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0x0f) -- channel mask -- 4 channels
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	clear_instrument(0)
	
	-- copy default instrument to 1..31
	for i=1,31 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	
	init_track(0x50000)
	
	-- copy to other tracks: 128k worth
	-- ** only first 399 are saved / undoable (0x20000\328) **
	-- 384 used in tracker
	--[[
	for i=1,398 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
	]]

end






:: debug.lua
--[[pod_format="raw",created="2024-03-13 08:36:45",modified="2024-05-16 21:54:33",revision=1072]]

function draw_mudo_state(x,y)
	rectfill(x,y,x+99,y+60,0)
	
	for i=0,7 do
		local sx = x + 2
		local sy = y + i * 6	
		
		-- chan->playing_track_index
		print("\14"..stat(400+i,12), sx, sy, 7)
		
		-- chan->inst		
		print("\14"..stat(400+i,1 ), sx+30, sy, 7)
		
		-- chan->track_row
		print("\14"..stat(400+i,9 ), sx+60, sy, 13)
		
	end
	print(string.format("cpu:%3.3f", stat(1)),x,y+52,13)
	print(tostr(something_is_playing),x+50,y+52,14)
end

:: env.lua
--[[pod_format="raw",created="2023-10-08 03:32:58",modified="2024-09-12 16:58:56",revision=7901,stored="2023-36-29 04:36:40"]]

-- flags: lerp, random start position
-- used by DATA envelope
function create_env_flag_toggle(addr,flag,label,x,y)
	local el = {
		addr = addr, flag = flag, label=label,
		x = x, y = y, width = 18+#label*4, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & self.flag
		--clip()
		--rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 
		--	(val>0 and 7 or 13))
		local str=val>0 and "[/] " or "[ ] "
		if (self.flag == 0x10) str = "" -- EF_ADVANCED_OPTS doesn't have checkbox
		print(str..self.label,2,1+yy,13)
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr)
		val ^^= self.flag
		poke(self.addr, val)
		refresh_gui = true
	end
	
	return el
end


env_type_str = {[0]=
	"adsr",
	"lfo",
	"data",
}



function create_env_type_toggle(addr,x,y)
	local el = { 
		addr = addr,
		x = x, y = y, width = 20, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & 0xf
		clip()
		--pal(7,1)
		rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 6)
		--spr(val,1,1+yy)
		print(env_type_str[val],2,1+yy,1)
		--pal()
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr)
		val = (val + 1) % 3
		poke(self.addr, (peek(self.addr) & 0xf0) | (val & 0x0f))
		refresh_gui = true
	end
	
	return el
end

function create_env_plug(index, x, y)
	local el = {
		x=x,y=y,width=7,height=7,index=index,
		click=checkpoint
	}
	function el:draw(msg)
		circfill(3,3,2,13)
		circ(3,3,2,1)
	end
	function el:release(msg)
		local sx=self.sx + msg.mx
		local sy=self.sy + msg.my
		
		local el2 = gui:el_at_xy(sx,sy)
		if (el2.drop_env_plug) el2:drop_env_plug{index=self.index}
		
	end
	
	return el
end


--[[
	edit an 8-bit value in memory
]]
function create_tiny_knob(label,addr,x,y,has_knob)
	local el={
		x=x,y=y,
		width=15,height=has_knob and 24 or 14,
		label=label,addr=addr,
		dval=0,
		cursor="dial"
		--cursor="grab" -- to do: dial spinning cursor that disappears
	}
	
	function el:draw()
		local val=peek(self.addr)
		if (has_knob) then
			circ(7,5,5,13)
			local aa=.7-val*.9/255.0
			line(7.5+cos(aa),5.5+sin(aa),7.5+cos(aa)*4,5.5+sin(aa)*4,7)
		end
		
		clip()
		
		-- 
		local yy=has_knob and 14 or 2
		rectfill(0,yy,14,yy+6,0)
		local str=tostr(val)
		print(str,14-#str*4,yy+1,3)
		
		print(self.label,9-#self.label*2,yy+10,13)

	end
	
	-- turn mouse locking on while dragging
	function el:click(msg)
		mouselock(0x4|0x8, 0.5, 0.05) -- 0x4 lock 0x8 auto-release, event speed, move speed 
	end
	
	function el:drag(msg)
		local val=peek(self.addr)
		-- accumulate change at 0.5 per pixel
		el.dval += (msg.dx - msg.dy) * 0.5
		if (el.dval <= -1) then
			val -= flr(-el.dval)
			el.dval += flr(-el.dval)
		end
		if (el.dval >= 1) then
			val += flr(el.dval)
			el.dval %= 1
		end
		val = mid(0,val,255)
		poke(self.addr, val)
		return true -- don't drag env_content
	end
	
--[[
	-- annoying
	-- doesn't mix with drag control
	-- pico-8 actually suffers from the same problem!
	-- (just not pronounced because easy to keep the cursor still,
	--  and hard to drag -1 or +1 while starting and ending inside el)
	
	function el:tap(msg)
		local val = peek(self.addr)
		local mag = key("ctrl") and 8 or 1
		val += msg.last_mb == 2 and -mag or mag
		poke(self.addr,mid(0,val,255))
	end
]]
	
	return el
end


function create_data_env_editor(addr, x, y, width, height)
	local el={
		addr=addr,
		x=x,y=y,width=width,height=height
	}
	function el:draw()
		rectfill(0,0,self.width-1,self.height-1,0)
		local ww=width\16
		local hh=self.height
		local loop0 = @(addr+3)
		local loop1 = @(addr+4)
		
		-- show loop points
		fillp(0x5a5a)
		col = loop0 < loop1 and 6 or 5
		line(loop0*ww-1,0, loop0*ww-1,self.height,col)
		line(loop1*ww-1,0, loop1*ww-1,self.height,col)
		fillp()
		
		-- show data
		for i=0,15 do
			local sx = i*ww
			local val = peek(self.addr+i+8)
			local col = i >= loop0 and i < loop1 and 13 or 12
			rectfill(sx,hh,sx+ww-2,hh-val*hh/255,col)
			rectfill(sx,hh-val*hh/255,sx+ww-2,hh-val*hh/255,28)
		end
		
	end
	
	function el:drag(msg)
		local ww=width\16
		local hh=self.height
		local xx=mid(0,msg.mx\ww,15)
		local yy=(msg.my) * 255 / self.height
		poke(self.addr+xx+8,mid(0,255-yy,255))
		return true -- don't drag env_content
	end
	
	return el
end


function create_env_editor(index, addr, label, x, y, width)

	local height = 46
	if (@addr == 1) height = 54 -- lfo
	if (@addr == 2) height = 86 -- data
	
	local height0 = height
	
	if (peek(addr+1)&0x10>0 and @addr<2) then
		height += 28
	end
	
	local pane = gui:attach(create_pane("\fh"..label, x, y, width, height, 0x0701))
	pane.index = index
	
	-- don't need plug! just drag whole pane
	--pane:attach(create_env_plug(index,2,1))
	
	
	pane:attach(create_env_type_toggle(addr,44,1))
	
	
	-- adsr
	if (peek(addr) == 0) then
		-- no labels: it's in the name of the envelope!
		--local knob_name={[0]="atk","dcy","sus","rel"}
		for i=0,3 do
			pane:attach(create_tiny_knob("",addr+8+i,2+i*20,16,true))
		end
	end
	
	-- lfo
	if (peek(addr) == 1) then
		pane:attach(create_tiny_knob("freq",addr+12+0,8,16,true))
		--pane:attach(create_tiny_knob("func",addr+13+0,31,28,false))
		pane:attach(create_tiny_knob("phase",addr+14+0,54,16,true))
		
	end
	
	-- data footer thing
	if (peek(addr) == 2 or peek(addr+1)&0x10>0) then
		
		if (peek(addr) != 2) then
			-- non-data only needs the start at rnd(t0), so can have more verbose version
			--pane:attach(create_env_flag_toggle(addr+1,0x8,"rnd start",20,pane.height-27))
			pane:attach(create_env_flag_toggle(addr+1,0x8,"rnd",46,pane.height-27))
		end
		
		-- starting from env_def[1]  -- env_def[0] is flags
		local knob_name={[0]="spd","lp0","lp1","t0"}
		for i=0,3 do
			pane:attach(create_tiny_knob(knob_name[i],addr+2+i,2+i*20,
				pane.height-20,false))
		end
		
	end
	
	-- data editor
	if (peek(addr) == 2) then
		pane:attach(create_data_env_editor(addr,0,9,80,48))
	
		-- lerp, rnd_start
		pane:attach(create_env_flag_toggle(addr+1,0x1,"lerp",2,pane.height-27))
		pane:attach(create_env_flag_toggle(addr+1,0x8,"rnd",46,pane.height-27))
		
	end
	
	-- show advanced options / ... button
	if (peek(addr) < 2) then
		local str="\f5\^:0000001500000000" -- ...
		if (peek(addr+1)&0x10>0) str="\f5\^:0000040e1f000000" -- up arrow
		pane:attach(create_env_flag_toggle(addr+1,0x10,str,width/2-6,height0-8))
	end
	
	-- don't scroll when grabbing "env-0" part of title bar
	--> so that can drag and drop without scrolling env container
	pane:attach{
		x=0,y=0,width=26,height=10,
		cursor="grab",
		click=function(self)
			grabbed_envelope = pane.index
			return
		end,
		drag=function()
			return true 
		end
	}
	
	-- can drag and drop anywhere on pane
	function pane:release(msg)
		local sx=self.sx + msg.mx
		local sy=self.sy + msg.my
		
		local el2 = gui:el_at_xy(sx,sy)
		if (el2 and el2.drop_env_plug) el2:drop_env_plug{index=self.index}
		
		grabbed_envelope = nil
	end
	
	return pane
end









































































:: gui.lua
--[[pod_format="raw",created="2023-10-22 07:32:11",modified="2024-09-12 16:58:56",revision=15444,stored="2023-36-29 04:36:40"]]

function create_pane(title, x, y, w, h, col, ontap)

	if (not col) col = 0x0705 -- default back
	
	local el={
		title=title,
		x=x,y=y,width=w,height=h,
		col=col
	}
	
	if (ontap) el.cursor = "pointer"
	
	function el:draw()
	
		local col = (self.col >> 0) & 0xff
		local hcol = (self.col >> 8) & 0xff
		
		rectfill(1,0,self.width-2,0,hcol)
		rectfill(0,1,self.width,8,hcol)
		rectfill(0,9,self.width-1,self.height-2,col)
		rectfill(1,self.height-1,self.width-2,self.height-1,col)
		
		--print(title,14,2,1) -- assume some kind of icon to the left
		local str = title
--		if (str == "instruments") str = string.format("inst %02x \f6(%d)", ci,ci)
		if (str == "sfx") str = "sfx "..flr(ct)
		print(str,6,2,1) -- assume some kind of icon to the left
		
	end
	
	-- on tap header
	function el:tap(msg)
		if (ontap and msg.my <= 9) ontap(self,msg)
	end
	
	return el
end

function extend_instrument_selection()
	if (ci < ci2) then
		ci0 = ci -- extend to left
		ci1 = ci2
	else
		ci1 = ci -- extend to right
		ci0 = ci2
	end
end

function extend_track_selection()
	if (ct < ct2) then
		ct0 = ct -- extend to left
		ct1 = ct2
	else
		ct1 = ct -- extend to right
		ct0 = ct2
	end
end

function extend_pattern_selection()
	if (cp < cp2) then
		cp0 = cp -- extend to left
		cp1 = cp2
	else
		cp1 = cp -- extend to right
		cp0 = cp2
	end
end


function create_instrument_chooser(el)
	local contents
	-- instrument chooser
	local container = el:attach{
		x=2,y=10,width=el.width-2,height=el.height-11,
		draw=function(self)
			-- some parent turned clipping off; can turn back on here
			clip(self.sx,self.sy,self.width,self.height)
		end,
		update=function(self)
			scroll[1] = contents.y
		end
	}
	contents = container:attach{
		x=0,y=0,width=86,height=512,
		draw=function(self)
			local i0 = mid(0, (-contents.y)\8, 63)
			local i1 = mid(0, i0 + 8, 63)
			for i=i0,i1 do
				if (i >= ci0 and i <= ci1 and mode=="instrument") then
					rectfill(0,i*8,self.width-1,i*8+6,31)
				end
				if (ci == i) then
					rectfill(0,i*8,self.width-1,i*8+6,
					mode=="instrument" and 14 or 16)
				end
				local fmt = (ci == i) and "%02x \f7%s " or "%02x \fd%s "
				print(string.format(fmt,i,get_inst_name(i)),0,1 + i*8, 7)--6)
				--print(string.format("%02i inst ",i),2,1 + i*8,6)
			end
		end,
		click=function(self,msg)
			ci = msg.my\8
			
			if (key"shift") then
				extend_instrument_selection()
				mode = "instrument"
			else
				ci0,ci1,ci2 = ci,ci,ci -- reset instrument selection
			end
			
			if (key"ctrl") set_mode("instrument")
			if (mode == "instrument") refresh_gui = true
		end,
		doubleclick = function(self,msg)
			ci = msg.my\8
			ci0,ci1,ci2 = ci,ci,ci
			set_mode("instrument")
			refresh_gui = true
		end
	}

	
	container:attach_scrollbars()
	
	-- start centered
	contents.y = -ci * 8 + 30
	if (scroll[1]) contents.y = scroll[1]

	-- clamp
	contents.y = mid(0, contents.y, - (contents.height - container.height))
end

sfx_thumb={}
function get_sfx_thumb(sfxi, use_cached)
	local addr = 0x50000 + sfxi * 328 + 8
	if not sfx_thumb[addr] or not use_cached then
		local bmp = userdata("u8",8,7)
		-- multiple dots per x
		for x=0,31 do
			local pitch = @(addr+x)
			local inst  = @(addr+x+64)
			if (inst != 0xff) set(bmp, x/4, mid(0,10-pitch/8,7), 8+(inst%24))
		end
--[[
		for x=0,7 do
			local pitch = 0
			local inst = 0xff
			for j=0,3 do
				local addr2=addr+x*4+j
				if (@addr2 > pitch) then
					pitch = @addr2 inst = @(addr2+64)
				end
			end
			set(bmp,x,10-pitch/6,8+(inst%24))
		end
--]]
		
		sfx_thumb[addr] = bmp
	end
	return sfx_thumb[addr]
end


function get_track_index_from_nav_mxy(mx, my)
	local xx  = mid(0, (mx-2) \ 9, 7)
	local yy  = (my-2)
	local yy1 = (yy\74)*8 + mid(0,(yy%74-8)\8,7)
	
	return flr(xx + yy1 * 8)
end
	


function create_track_chooser(el)

	local contents
	local container = el:attach{
		x=1,y=10,width=el.width-2,height=el.height-10,
		draw=function(self)
			-- some parent turned clipping off; can turn back on here
			clip(self.sx,self.sy,self.width,self.height)
		end,
		update=function(self)
			scroll[2] = contents.y
		end
	}
	
	contents = container:attach{
		x=0,y=0,width=86,height=74*6+2,
		draw=function(self)
		
			for group = 0,5 do
				local x = 2
				local y = 2 + group * 74
				print(string.format("%03d",group*64),x,y,13)
				y+=8
				-- clip by group
				if y + contents.y > -74 and y + contents.y < container.height then
				for i = group*64, group*64+63 do
					-- clip by line
					if y + contents.y > -12 and y + contents.y < container.height then
						rectfill(x,y,x+7,y+6,0)
						
						if (i >= ct0 and i <= ct1 and mode =="track") then
							-- track selection
							rect(x-1,y-1,x+8,y+7, 10)
						end
						if (ct == i) then
							-- current track highlighted
							rect(x-1,y-1,x+8,y+7, focus=="track_item" and 7 or 13)
						end
						
						-- show is playing
						local pr = playing_row(i)
						if (pr) then
							rectfill(x,y,x+7,y+6,5) -- just highlight background
							-- show position. not that useful!
							--line(x+pr/8, y, x+pr/8, y+6, 7)
							-- blinky bars: cuter, but too much
							--[[
							for j=0,2 do
								rectfill(x+j*3,y+6,x+1+j*3,y+6-max(cos(-j*.3+t()*3))*2,
									(time()*2+j/5)%1<.4 and 6 or 13)
							end
							]]
						end
						
						spr(get_sfx_thumb(i, i != ct),x,y)
						
					end
				
					x += 9
					if (x > 72) then
						x = 2 y += 8
					end
				
				end
				end
			end	

--[[
			for i=0,383 do
				local x = 2 + (i % 8) * 9
				local y = 2 + (i \ 8) * 8 + (i\64)*10
				--rectfill(x,y,x+7,y+6, ct == i and 29 or 18)
				rectfill(x,y,x+7,y+6,0)
				if (ct == i) rect(x-1,y-1,x+8,y+7,7)
				-- thumb
				local dat_addr = 0x50000 + i * 328 + 8
				spr(get_sfx_thumb(dat_addr, i != ct),x,y)
				
				--print(string.format("%02x",i),x+1,y+1,1)
				if (playing_row(i)) then
					for j=0,2 do
						--circfill(x+4+j*4,y+10,.8+cos(-j*.3+t()*2), 7)
						rectfill(x+3+j*4,y+11,x+5+j*4,y+11-max(cos(-j*.3+t()*3))*2,7)
					end
				end
			end
			]]
		end,
		
		release=function(self,msg)
			
			local sx=self.sx + msg.mx
			local sy=self.sy + msg.my
			
			local el2 = gui:el_at_xy(sx,sy)
			if (el2 and el2.drop_track_index) el2:drop_track_index{index=grabbed_track}
			
			grabbed_track = nil
		end,
		
		click=function(self, msg)
			grabbed_track = get_track_index_from_nav_mxy(msg.mx, msg.my)
			grabbed_track_t = time()
		end,
	
		
		tap=function(self, msg)
			checkpoint()
				
			ct = get_track_index_from_nav_mxy(msg.mx, msg.my)
			if (key"shift") then
				extend_track_selection()
			else
				ct0,ct1,ct2 = ct,ct,ct -- reset track selection
			end
			set_mode("track")
			refresh_gui = true
		end
	}
	container:attach_scrollbars()
	
	if (mode == "track") then
		-- if already in track mode, don't need to be able to
		-- drag track, and want selection be snappier (happen
		-- on click instead of tap)
		contents.click = contents.tap
		contents.tap = nil
	end
	
	if (scroll[2]) contents.y = scroll[2]
	
	
end

-- 128 patterns
-- can add a way to add more later, but > 128 becomes awkward to navigate
function create_pattern_chooser(el)

	local contents
	local container = el:attach{
		x=2,y=10,width=el.width-2,height=el.height-11,
		draw=function(self)
			-- some parent turned clipping off; can turn back on here
			clip(self.sx,self.sy,self.width,self.height)
		end,
		update=function(self)
			scroll[3] = contents.y
		end
	}
	contents = container:attach{
		x=0,y=0,width=86,height=(128/4*12)+4,
		
		draw=function(self)
			local playing_pattern = stat(466)
			i0 = mid(0, ((-contents.y) \ 12) * 4, 127)
			i1 = mid(0, i0 + 23, 127)
			for i=i0,i1 do
				local addr = 0x30100 + i * 20
				local flags = peek(addr+8)  -- flow flags
				local mask =  peek(addr+9) -- channel mask -- 4 channels
				
				local x = 0 + (i % 4) * 19
				local y = 2 + (i \ 4) * 12
				rectfill(x,y,x+16,y+8,
					(i >= cp0 and i <= cp1 and mode=="pattern") and 
					(focus == "pattern" and 14 or 30) or 
					(mask == 0 and 0 or 18))
				--rect(x,y,x+16,y+8, cp == i and 14 or 13)
				
				-- loop0: cut top left corner
				if (flags & 1 > 0) then
					pset(x,y,1)
					line(x,y+1,x+1,y,1)
				end
				-- loop1: cut top right corner
				if (flags & 2 > 0) then
					pset(x+16,y,1)
					line(x+16,y+1,x+15,y,1)
				end
				-- stop: cut bottom right corner
				if (flags & 4 > 0) then
					pset(x+16,y+8,1)
					line(x+16,y+7,x+15,y+8,1)
				end
				
				if (mask == 0) then
					
				elseif (mask & 0xf0) > 0 then
					-- 8 channels
					for j=0,7 do
						local index = @(addr+j)
						pset(1+x+j*2,y+10,(mask & (1<<j)) > 0 and 8+(index%16) or 0)
					end
				else
					-- only use channels 0..3
					for j=0,3 do
						local index = @(addr+j)
						local xx=1+x+j*4
						local yy=y+10
						line(xx,yy,xx+2,yy,(mask & (1<<j)) > 0 and 8+(index%16) or 0)
					end
				end
				local istr=string.format("%02i",i)
				print(istr,x+9-#istr*2,y+2, cp == i and 7 or 1)
				
				-- blinky verion when playing back
				
				if (playing_pattern == i) then
					local ww = (mask & 0xf0) > 0 and 2 or 4
					local jj = (mask & 0xf0) > 0 and 7 or 3
					for j=0,jj do
						local index = @(addr+j)
						local col = (mask & (1<<j)) > 0 and 8+(index%16) or 0
						local xx=1+x+j*ww
						local yy=y+10
						if ((time()*2-(j*5.7))%1 < 0.4) col = 7 -- blink white
						rectfill(xx,yy+cos(time()*2-j/5)*0.5,xx+ww-2,yy,col)
					end
				end
				
			end
		end,
		
		tap=function(self, msg)
			checkpoint()
			cp = flr(mid(0, msg.mx \ 20, 3) + ((msg.my-2) \ 12) * 4)
			
			if (key"shift") then
				extend_pattern_selection()
			else
				cp0,cp1,cp2 = cp,cp,cp -- reset pattern selection
			end
			
			set_mode("pattern")
			refresh_gui = true
		end
	}
	container:attach_scrollbars()
	
	contents.y = -(cp\4) * 12 + 20
	if (scroll[3]) contents.y = scroll[3]

	-- clamp
	contents.y = mid(0, contents.y, - (contents.height - container.height))
	
end

function create_volume_chooser(x, y)
	local el ={
		x = x, y = y, width=48, height = 7,
		cursor = "pointer"
	}
	function el:draw(msg)
		clip()
		if (msg.mb>0 and msg.has_pointer) then
			print(cvol,-15,1,16)
		else
			print("vol",-15,1,16)
		end
		for i=0,7 do
			local sx = i * 5
			rectfill(sx,0,sx+4,6, (i+1)*0x8 == cvol&(~0x7) and 6 or 13)
			--print("\014"..(i+1),sx+1,1,13)
		end
	end
	function el:drag(msg)
		cvol = mid(1,(1+(msg.mx\5)),8)*0x8
	end
	
	return el
end

 
function create_octave_chooser(x, y)
	local el ={
		x = x, y = y, width=48, height = 7,
		cursor = "pointer"
	}
	function el:draw()
		clip()
		print("oct",-15,1,16)
		for i=0,7 do
			local sx = i * 5
			rectfill(sx,0,sx+4,6,i+1 == coct and 6 or 13)
			print("\014"..(i+1),sx+1,1,i+1 == coct and 13 or 13)
		end
	end
	function el:drag(msg)
		coct = mid(1,1+(msg.mx\5),8)
	end
	
	return el
end


function generate_gui_track()

	local xx = 92
	track_pane = gui:attach(create_pane("\f6sfx "..ct,xx,4,384,82,0x1001))
	
	track_pane.click = function()
		-- copy/paste applies to the whole sfx, not note selection 
		-- click on track to change focus to track (note selection)
		focus = "track_item"
	end
	
	focus = "track_item"
	
	local track_addr = 0x50000 + ct * 328
	-- don't expose length for now; always 64
	-- future: when change len, need to update stride to match!
	--track_pane:attach(create_tiny_num_field("len",  track_addr + 0,100,1))
	
--[[ deleteme -- moved to left pane
	track_pane:attach(create_octave_chooser( 75,1))
	track_pane:attach(create_volume_chooser(145,1))
]]

-- is not just play length -- dictates how data is arranged (stride between columns)
--	track_pane:attach(create_tiny_num_field("len",  track_addr + 0,230,1,  1,64))

	
	track_pane:attach(create_tiny_num_field("spd",  track_addr + 2,260,1,1))
	track_pane:attach(create_tiny_num_field("loop0", track_addr + 3,310,1))
	track_pane:attach(create_tiny_num_field("loop1",track_addr + 4,360,1))
	
	-- 8 segments of same track
	for i=0,7 do
		track_pane:attach(create_track_segment{
			x=2 + i * 48, y=12, rows=8,
			row0 = i*8,
			index = ct -- sfx_index
		})
	end
	
	
	gui:attach(create_pane("\f6pitch ",xx,90,384,88,0x1000))
		:attach(create_pitch_scribbler{
			x=0,y=10,width=384,height=76,addr=track_addr + 8,stride=64})
	
	gui:attach(create_pane("\f6volume ",xx,180,386,76,0x1000))
		:attach(create_volume_scribbler{
			x=0,y=10,width=384,height=66,addr=track_addr + 8 + 128,stride=64})
	
end

local function create_flow_toggle(el)
	el.width = 7
	el.height = 7
	el.cursor = "pointer"
	local addr = 0x30100 + cp*20+8
	function el:draw()
		poke(0x30100 + cp*20+8)
		local selected = (peek(addr) & el.bit) > 0
		--rectfill(0,0,6,6,selected and 10 or 13)
		pal(7, selected and 10 or 1)
		spr(el.icon,0,0)
		pal()
	
	end
	function el:tap()
		poke(addr, peek(addr) ^^ el.bit)
	end
	return el
end


local function create_inst_flag_toggle(el)
	local inst_addr = 0x40000 + ci*0x200
	local el = el or {}
	el.width = 40
	el.height = 17
	el.cursor = "pointer"
	local addr = inst_addr + 0x1df -- one byte before wt definition
	function el:draw()
		local selected = (peek(addr) & el.bit) > 0
		rectfill(1,1,5,5,1)
		if (selected) rectfill(2,2,4,4,7)
		print(el.label, 10, 1, selected and 7 or 1)
	end
	function el:tap()
		poke(addr, peek(addr) ^^ el.bit)
		refresh_gui = true
	end
	return el
end


function create_channel_scope(i, x, y)
	local el={
		x=x,y=y,
		width=40, height=20
	}
	function el:draw()
		rectfill(0,0,self.width-1, self.height-1,0)
		if (something_is_playing) then
			local n = stat(400+i,19,0x90000)
			for xx=0,self.width-1 do
				local yy=10+peek2(0x90000+ xx*16)/3276
				pset(xx, yy, 16)
				yy=10+peek2(0x90002+ xx*16)/3276
				pset(xx, yy, pget(xx,yy)==0 and 24 or 30)
				
				
			end
		end
	end
	
	return el
end


function generate_gui_pattern()

	local pane = gui:attach(create_pane("\f6pattern "..cp,92,4,384+4,252,0x1001))
	
	pane.click = function() 
		focus = "pattern"
	end
	
	-- focus for copying / pasting
	focus = "pattern"

--[[ deleteme
	pane:attach(create_octave_chooser( 75,1))
	pane:attach(create_volume_chooser(145,1))
]]

	-- playback flow flag toggles: start, end, stop
	
	pane:attach(create_flow_toggle{
		x = 350, y = 1, bit = 0x1, icon = get_spr(58)
	})
	pane:attach(create_flow_toggle{
		x = 360, y = 1, bit = 0x2, icon = get_spr(59)
	})
	pane:attach(create_flow_toggle{
		x = 370, y = 1, bit = 0x4, icon = get_spr(60)
	})
	
	
	local container = pane:attach{
		x=0,y=24+22,width=pane.width,height=228-32,
		draw=function()	end -- to get clipping
	}
	

	local contents = container:attach{
		x=0, y=0, width=pane.width, height=521,
		draw = function()
			-- markers showing rows
			--[[
			fillp(0xf000)
			for i=0,7,2 do
				rectfill(0,i*64, 1000,i*64+64,16+i/2)	
			end
			fillp()
			]]
		end
		
	}
	
	pattern_contents = contents
	
	-- whole track for each channel
	local chan_mask = peek(0x30100 + cp * 20 + 9)
	track_seg_el = {}
		
	for i=0,7 do
	
		local sx = 2 + i*47
		local sy = 13
		local ww = 7
		
		-- drag and drop track index into a channel to assign it
		-- (callback on any channel-specific elements)
		local drop_track_index = function(self,msg)
			checkpoint()
			chan_mask |= (1 << i)
			poke(0x30100 + cp*20+9, chan_mask)
			poke(0x30100 + cp*20+i, msg.index)
			refresh_gui = true
		end
		
		
		if (chan_mask & (1 << i) > 0) then
			local tiny = pane:attach(
				create_tiny_num_field("",0x30100 + cp * 20 + i, sx+15, sy)
			)
			
			tiny.drop_track_index = drop_track_index
			
		else
			ww = 24
		end
		
		pane:attach(create_channel_scope(i, sx+2, sy+10))
		
		-- toggle channel bit
		pane:attach{
			x = sx+5, y = sy,
			width=ww, height = 7,
			draw=function(self)
				rect(0,0,6,6,5)
				if (chan_mask & (1 << i) > 0) then
					rect(0,0,6,6,16)
					rectfill(2,2,4,4,6)
				else
					rectfill(9,0,24,7, 0)
				end
				
			end,
			tap=function()
				chan_mask ^^= (1 << i)
				poke(0x30100 + cp*20+9, chan_mask)
				refresh_gui = true
			end,
			drop_track_index=drop_track_index
			
		}
		
		-- edit track
		pane:attach{
			x = sx+33, y = sy,
			width=ww, height = 7, cursor="pointer",
			draw=function(self)
				spr(23,0,0)
			end,
			tap=function()
				mode="track"
				ct=peek(0x30100 + cp * 20 + i)
				refresh_gui = true
			end
		}
	
		if (chan_mask & (1 << i) > 0) then
			track_seg_el[i] = contents:attach(create_track_segment{
				x= sx, y=0, rows=64,
				live_index = true,
				chan_i = i,
				index = peek(0x30100 + cp * 20 + i), -- track (sfx) index
				drop_track_index=drop_track_index
			})
		else
			-- dummy
			contents:attach{
				x=sx, y=0,
				width = 44, height = 64 * 8 + 2, -- match size in create_track_segment
				draw = function(self, msg)
					rectfill(0,0,self.width-1,self.height-1, 0)
					if (grabbed_track and
						msg.mx>=0 and msg.mx <self.width and msg.my >= 0 ) then
						rect(0,0,self.width-1,self.height-1, 10)
					end
					--rect(0,0,self.width-1,self.height-1, 5)
				end,
				drop_track_index=drop_track_index
			}
		end
		
		-- jump to channel pencil
	end
	
	container:attach_scrollbars()
	
	-- info at bottom
	pane:attach{
		x=3,y=244,width=80,height=10,
		draw=function()
			if (something_is_playing and following_playback) then
				local row = stat(400 + stat(467),9)
				print("playing row: "..flr(row),0,0,13)
			else
				local row = cur_y - (0x50000 + (ct * 328) + 8)
				print("row: "..flr(row),0,0,13)
			end
			
		end
		
	}
	

end


function create_play_button()
	local el = gui:attach{
		x=2,y=3,
		width=26,height=17,
		cursor="pointer"
	}
	
	function el:draw()
		rectfill(1,0,self.width-2,self.height-1,13)
		rectfill(0,1,self.width-1,self.height-2,13)
		spr(something_is_playing and 63 or 62,5,1)
	end
	
	-- use tap so that following_playback is not cancelled by click
	function el:tap()
		if something_is_playing then
			note()
		elseif mode == "instrument" then
			-- play insturment on channel 8
			-- will be release in _update()
			note(coct*12,ci,cvol,0,0, 8, true)
		elseif mode == "track" then
			sfx(ct)
		elseif mode == "pattern" then
			music(cp) following_playback = true
		end
	end
	
end


function set_mode(which)
	checkpoint()
	-- last_mode used to decide if space plays sfx or pattern (from inst editor)
	if (last_mode ~= mode) last_mode = mode 
	mode = which
	readtext(true) -- clear buffer
	refresh_gui = true
end

function generate_gui()

	ci = mid(0,ci,63)
	ct = mid(0,ct,383)
	cp = mid(0,cp,127)
	
	gui = create_gui()

	-- mode buttons; now redundant -- use chooser headers, or press tab
--[[	
	local mode_label={[0]="inst","sfx","pat"}
	local mode_name ={[0]="instrument","track","pattern"}
	
	for i=0,2 do
		gui:attach{
			x=2 + i*29,y=2+21,
			width=27,height=11,
			label=mode_label[i],
			mode=mode_name[i],
			draw=function(self)
				local sel = self.mode==mode
				rectfill(0,0,self.width-1,self.height-1, sel and 14 or 1)
				print(self.label,self.width/2 - #self.label*2, 3,sel and 7 or 13)
			end,
			tap=function(self)
				checkpoint()
				mode = self.mode
				readtext(true) -- clear buffer
				refresh_gui = true
			end
		}
	end
]]
	-- play button
	
	create_play_button()
	
	-- octave and volume choosers
	
	gui:attach(create_octave_chooser(47,3))
	gui:attach(create_volume_chooser(47,13))
	
	local yy = 37-14
	local ww = 86 
	local pcol = mode == "instrument" and 0x0e01 or 0x0701
	local el = gui:attach(
		create_pane("instruments",2,yy,ww,63+14, pcol,
		function() set_mode("instrument") end))

	--[[ 
		--pencil to show can click to enter instrument mode? not consistent
		-- can can double click anyway
		el:attach{x=78,y=1,width=7,height=7,
			cursor="pointer",
			draw=function()spr(23,0,0)end
		}
	]]
	create_instrument_chooser(el)
	yy += el.height + 4
	
	pcol = mode == "track" and 0x0e01 or 0x0701
	local el = gui:attach(create_pane("sfx",2,yy,ww,76,pcol,
		function() set_mode("track") end))
	create_track_chooser(el)
	yy += el.height + 4
	
	pcol = mode == "pattern" and 0x0e01 or 0x0701
	local el = gui:attach(create_pane("patterns",2,yy,ww,72,pcol,
		function() set_mode("pattern") end))
	create_pattern_chooser(el)
	

	if (mode == "instrument") generate_gui_instrument()
	if (mode == "track")      generate_gui_track()
	if (mode == "pattern")    generate_gui_pattern()
	
end


function add_instrument_attributes(parent)

	-- instrument attributes (put inside node_content -- can scroll out)
	
	inst_name_editor = parent:attach_text_editor{
		x=24, y=1,
		width = 72, height=7,
		bgcol = 1, fgcol = 6, curcol = 8,
		block_scrolling = true, max_lines = 1,
		margin_top = 1,
		key_callback = {
			enter = function () 
				set_inst_name(ci,inst_name_editor:get_text()[1])
				inst_name_editor:set_keyboard_focus(false)
			end
		},
		update = function(self)
			-- update in realtime -- don't need to press enter to change
			if (inst_name_editor:has_keyboard_focus()) then
				set_inst_name(ci,inst_name_editor:get_text()[1])
			end
		end
	}
	inst_name_editor:set_text{get_inst_name(ci)}
	
	parent:attach(create_inst_flag_toggle{
		x = 110, y = 1,
		bit = 0x1,
		label = "retrig" -- means: "always retrigger when inst is given in row"
	})
	
	parent:attach(create_inst_flag_toggle{
		x = 154, y = 1,
		bit = 0x2,
		label = "wide" -- means: "can vary panning of depth:1 osc nodes"
	})
	
end


function generate_gui_instrument()
	
	-- add nodes to a scrollable area
	
	local node_container = gui:attach{
	
		x = 92, y = 0, width = 300, height = 252,

		mousewheel = function(self, msg)
			self.child[1].y += msg.wheel_y * 16
			self.child[1].y = mid(0, self.child[1].y, self.height - self.child[1].height)
			last_node_content_inst = ci
			last_node_content_y = self.child[1].y
		end,
		
		drag = function(self, msg)
			self.child[1].y += msg.dy
			self.child[1].y = mid(0, self.child[1].y, self.height - self.child[1].height)
			last_node_content_inst = ci
			last_node_content_y = self.child[1].y
		end,
		
		update = function(self)
			--if (self.child[1]) self.child[1].y += 1
		end
	}
	
	local node_content = node_container:attach{
		x=0,y=0,width=node_container.width,height=300
	}
	
	local yy = 4
	node_depth={}
	node_parent_index={}
	
	
	-- calculate node depth first
	-- (needed to decide when to create sibling shuffle buttons)
	for i=0,7 do
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + i*0x20
		local node_type = peek(node_addr+1) & 0xf
		local node_parent = peek(node_addr+0) & 0x7
		
		node_depth[i] = node_depth[node_parent] and node_depth[node_parent]+1 or 0
		node_parent_index[i] = node_parent
		if (node_type == 0) node_depth[i] = -1
	end
	
	for i=0,7 do
	
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + i*0x20
		local node_type = peek(node_addr+1) & 0xf
		local node_parent = peek(node_addr+0) & 0x7
		
		local x0 = node_depth[i] * 8
	
		if (node_type > 0) then
			local n = create_node_editor(node_content, i, x0, yy, node_depth[i])
--[[ deleteme
			if (i == 0) then
				n:attach(create_octave_chooser(80,1))
				n:attach(create_volume_chooser(145,1))
			end
]]
			if (i==0) add_instrument_attributes(n)	
			
			yy += n.height + 4
		end
		
		node_content.height = max(yy + 16, node_container.height)
		
		
	end
	
	
	-- envelope container
	-- (dupe from node_container)

	local env_container = gui:attach{
	
		x = 396, y = 0, width = 84, height = 250,

		mousewheel = function(self, msg)
			self.child[1].y += msg.wheel_y * 16
			self.child[1].y = mid(0, self.child[1].y, self.height - self.child[1].height)
			last_env_content_inst = ci
			last_env_content_y = self.child[1].y
		end,
		
		drag = function(self, msg)
			self.child[1].y += msg.dy
			self.child[1].y = mid(0, self.child[1].y, self.height - self.child[1].height)
			last_env_content_inst = ci
			last_env_content_y = self.child[1].y
		end,
		
		update = function(self)
			--if (self.child[1]) self.child[1].y += 1
		end
	}
	

	-- envelopes
	
--	local env_content = gui:attach{
--		x=396,y=0,width=100,height=300
--	}
	local env_content = env_container:attach{
		x=0,y=0,width=env_container.width,height=400
	}
	
	local yy = 4
	for i=0,4 do -- 0.1.0h: 5 envelopes fit nicely; usually enough?
		local inst_addr = 0x40000 + ci*0x200
		local env_addr = inst_addr + 256 + i * 24
		local e = env_content:attach(create_env_editor(i,env_addr,"env-"..i,0,yy,80))
		yy += e.height + 4
	end
	
	env_content.height = max(yy + 16, env_container.height)
	
	-- preserve node content scroll position
	-- to do: find a less silly way to do this
	if (last_node_content_inst == ci) then
		node_content.y = last_node_content_y
	end
	if (last_env_content_inst == ci) then
		env_content.y = last_env_content_y
	end
	
end


:: inst.lua
--[[pod_format="raw",created="2023-10-27 18:16:38",modified="2024-09-12 16:58:56",revision=9459]]

function get_inst_name(i)
	local inst_addr = 0x40000 + i*0x200
	local len = 16
	for j=15,0,-1 do
		if (peek(inst_addr+496+j) == 0) len = j
	end
	return chr(peek(inst_addr+496,len))
end

function set_inst_name(i, str)
	local inst_addr = 0x40000 + i*0x200
	memset(inst_addr+496,0,16)
	poke(inst_addr+496,ord(str,1,min(16,#str)))
end



-- 0x1702
local node_type_col = {
	[0]=0x1,0x0e05,0x0705,0x5,
	0,0,0,0,
	0x0c05,0x0c05,0x0c05,0x0c05,
	--0x1105,0x0c05,0x1905,0x0805,
}

-- labels: max 5 chars (4 preferred)

function create_mval_knob(label,node_type,mval_index,addr,x,y)

	local el = {
		x = x, y = y, 
		width = 54, -- includes the number box; and envelope connection
		height = 20,
		label=label,
		addr=addr,
		mval_index=mval_index,
		v0 = -128, v1 = 127, -- editable range for signed values
		vz = 0, -- "zero" -- where to fill pie from / until
		ac = 1, -- angle coefficient (notch angle)
		a0 = 0.0,
		-- cursor = "grab", -- to do: shouldn't set cursor while drag outside of element
		node_col = node_type_col[node_type],
		click = checkpoint,
		dval = 0,
		cursor = "dial"
		--cursor="grab" -- to do: dial spinning cursor that disappears
	}
	
	if (label == "vol") el.v0, el.v1 = 0, 64
	
	-- maybe later
	--if (label == "tune") el.v0,el.v1 = -120, 120 el.ac = 20 el.a0 = 0.5
	if (label == "wave") el.v0,el.v1 = 0, 255
	
	-- fx parameters are all 0..255 (flag 0x8 is not set)
	if (node_type >= 8) el.v0,el.v1 = 0, 255
		
	-- gain mix; can use *8 if want to over mix!
	if (label == "mix") el.v0, el.v1 = 0, 64
	
	function el:drop_env_plug(msg)
		checkpoint()
		--printh("setting "..pod(msg))
		poke(addr+3, (peek(addr+3) & ~0xf) | msg.index)
		--set observe_envelope bit
		poke(addr, peek(addr) | 0x4)
	end
	
	function el:update(msg)
		if (not (msg.mx and msg.my)) return -- to do: should that ever happen?
		self.cursor = (msg.mx < 18) and "dial" or "pointer"
	end
	
	function el:draw(msg)
	
		--rectfill(0,0,1000,1000,8+addr/4)
			
		local xx,yy = 8.5,6.5
		
		circfill(xx-1,yy+1,7,(self.node_col&0x5 == 5) and 1 or 21)
		circfill(xx,yy,7,0)
		
		-- draw mval	
		local flags,val1,val0,env = peek(addr,4)
		local num = 1 + val1 % 16
		local den = 1 + val1 \ 16
		
		
		if (el.v1 < 128) then -- signed int8's
			if (val1 >= 128) val1 -= 256
			if (val0 >= 128) val0 -= 256
		end
		
		local range = self.v1 - self.v0
		
		-- 0.7 - 0.9 * ..
		--local p0,p1 = 0.7,0.9 -- wedge at bottom
		local p0, p1 = 0.75, 1.0 
		
		
		local a0 = self.a0 + p0 - p1 * (val1 - self.v0) * self.ac / range
		
		local a1 = p0 - p1 * (val0 - self.v0) / range
		
		
		--local a1 = self.a0 + p0 - (self.vz - self.v0) * self.ac * p1 / range
	
		-- show range (to do: decide on flags for that)
		color (peek(self.addr) & 0x4 > 0 and 12 or 14)
		
		-- ** to do: optimise **
		if (false) then  
			for k=0,1,1/(abs(a1-a0)*32) do
				local aa = a1+(a0-a1)*k
				line(xx,yy,xx+cos(aa)*6, yy+sin(aa)*6)
			end
		end
		
		-- dotty arc version

		local aa0,aa1 = a0, a1
		if (aa0 > aa1) aa0,aa1 = aa1,aa0
		for aa = -.25, .75, 1/32 do
			if (aa >= aa0 and aa <= aa1) then
				pset(xx+cos(aa)*5, yy+sin(aa)*5)
			end
		end		
		
		line(xx+cos(a0)*2, yy+sin(a0)*2, xx+cos(a0)*6, yy+sin(a0)*6, 7)

		clip()
		print(self.label, -20,4,6)
		
		rectfill(xx+7,2,xx+36,10,0)
		
		-------------------------------------------
		--   envelope assignment plug to right   --
		-------------------------------------------
		
		if (peek(self.addr) & 0x4 > 0) then
			rectfill(xx+37,2,xx+44,10,7)
			rectfill(xx+37,3,xx+45,9,7)
			
			if (peek(self.addr) & 0x8 > 0) then
				print(peek(self.addr+3)&0xf, xx+40, 3, 12)
				print("\^:1500000000000000",xx+39,9,12) -- 3 dots
			else
				print(peek(self.addr+3)&0xf, xx+40, 4, 12)
			end
		else
			-- choose randomly from range
			if (peek(self.addr) & 0x10 > 0) then
				rectfill(xx+37,2,xx+44,10,14)
				rectfill(xx+37,3,xx+45,9,14)
				print("r", xx+40, 4, 7)
			end
		end
		
		-------------------------------------------
		--      scale underneath at right        --
		-------------------------------------------
		
		local sval = peek(self.addr+3)
		
		if (sval & 0xc0 > 0) then

			str2 = (sval & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			
			if (sval & 0xc0 == 0x40) str2 ..= "\^:5070400000000000" -- 4
			if (sval & 0xc0 == 0x80) str2 ..= "\^:1372770000000000" -- 16
			if (sval & 0xc0 == 0xc0) str2 ..= "\^:5177470000000000" -- 64
			
			--rectfill(xx+24,11,xx+36,15,13)
			print(str2, xx+20,12,7)
		end
		
		-------------------------------------------
		--     value and parent relationship     --
		-------------------------------------------
		
		if (flags & 0x3 > 0) then
			local letter = "?"
			if (flags & 0x3 == 0x1) letter = "+"
			if (flags & 0x3 == 0x2) letter = "*"
			print(letter,35-4*4,4,3)
		end
		
		-- show value
		local str, str_col = tostr(val1), 27
		
		if (msg.mb == 2 and msg.has_pointer and
			 msg.mx <= 44 and msg.my <= 12) then
			str = tostr(val0)
			str_col = 14
		end
		
		if (flags & 0x3 == 2 and label=="tune") then
			-- multiply by ratio
			-- only makes sense for pitch
			str = num.."/"..den
		end
		
		-- everything else: show raw value
		print(str, xx+35-#str*4, 4, str_col)
		
		circ(xx,yy,7,13)--self.node_col&0xff)
		--circ(xx,yy,8,node_col&0xff)
		
		
	end
	
	-- turn mouse locking on while dragging (and set undo checkpoint)
	function el:click(msg)
		mouselock(0x4|0x8, 0.5, 0.05) -- 0x4 lock 0x8 auto-release, event speed, move speed 
		checkpoint()
	end
	
	function el:drag(msg)
		local flags,val1,val0,env = peek(addr,4)
	
		local dval = (msg.dx - msg.dy)
		
		if (self.label=="tune" and (flags & 3) == 2) then
			-- special case: use u8 for integer fraction mode
			val1 = mid(0, val1 + dval, 255)
		else
			-- signed int8 behaviour
			if (el.v1 < 128) then 
				if (val0>=128) val0 -= 256
				if (val1>=128) val1 -= 256
			end
			
			if (msg.mb > 1) then
				-- drag val0 (start of range)
				val0 = mid(self.v0, val0 + dval, self.v1)
			else
				-- regular white needle dragging
				val1 = mid(self.v0, val1 + dval, self.v1)
			end	
		
		end
		
		poke(addr+1,val1)
		poke(addr+2,val0)
		return 1 -- don't drag the node content
	end
	
	function el:tap(msg)
		checkpoint()
		local flags,val1,val0,env = peek(addr,4)
		
		-- use same gui el / can still grab and drag value without
		-- having to avoid the operator area. usually operator stays
		-- untouched, so preferable to have a little friction to change it.
		
		if (msg.my > 11 and msg.mx > 34) then
			-- change scale bits
			local ctrl_held = key("ctrl")
			local val = peek(addr+3) & 0xe0
			if (val == 0)        then val = 0x00 | 0x40 -- *4
			elseif (val == 0x40) then val = 0x20 | 0x40 -- /4
			elseif (val == 0x60 and ctrl_held) then val = 0x00 | 0x80 -- *16
			elseif (val == 0x80 and ctrl_held) then val = 0x20 | 0x80 -- /16
			elseif (val == 0xa0 and ctrl_held) then val = 0x00 | 0xc0 -- *64
			elseif (val == 0xc0 and ctrl_held) then val = 0x20 | 0xc0 -- /64
			else val = 0 end
			poke(addr+3,(peek(addr+3) & ~0xe0) | val)
		elseif (msg.mx >= 18 and msg.mx <= 24) then
		
			-- change parent operator
			
			if node_type >= 8 and self.label ~= "res" and self.label ~= "mix" then
				-- filter:res and shape:mix can multiply with parent.
				-- any other fx filter mvals shouldn't have any parent operators
				poke(addr, flags & ~0x3)
			elseif (flags & 0x3 > 0) then
				if (self.label == "tune") then
					poke(addr, (flags & ~0x3) | ((flags & 2 > 0) and 0 or 2))
				else
					poke(addr, flags & ~0x3) -- clear add / mult bit
				end
			else
				if (self.label == "vol" or self.label == "mix" or self.label == "res")
				then
					-- set bit: mult parent
					poke(addr, flags | 0x2)
				else
					-- set bit: add parent
					poke(addr, flags | 0x1)
				end
			end
		elseif (msg.mx >= 45) then
			-- toggle envelope assignment bit
			-- mb2 to toggle continuation
			if (peek(addr) & 0x4 > 0 or msg.last_mb == 1) then
				poke(addr, peek(addr) ^^ (msg.last_mb == 1 and 0x4 or 0x8))
			else
				-- toggle rnd
				poke(addr, peek(addr) ^^ 0x10)
			end
		else
			-- set val0 to val?
			-- nah -- just always drag mb2
			-- poke(addr+2,val1)
		end
	end
	
	
	return el
end

function get_mval_scale(addr)
	local val = @addr
	local bits = 0
	if (val & 0xc0 == 0) return 1
	if (val & 0x40 >  0) bits += 2
	if (val & 0x80 >  0) bits += 2
	return (val & 0x20) > 0 and 1/(1<<bits) or (1<<bits)
end


-- address is of the wavetables
function create_scope(addr, node_index, x, y, w, h)
	local el = gui:attach{
		x=x,y=y,
		width=w, height=h,
		addr=addr,
		bmp=userdata("u8",w,h),
		dither_t = 7,
		refresh = true
	}
	function el:click(msg)
		checkpoint()
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + node_index*0x20
		local wt_index = peek(node_addr+1)>>4
		
		if (msg.mx < 18 and msg.my < 10) then
			wt_index = (wt_index + 1) % 4
			poke(node_addr+1, (peek(node_addr+1) & ~0xf0) | (wt_index << 4))
		end
	end
	
	function el:draw(msg)
	
		self.dither_t = (self.dither_t + 1) % 8

		set_draw_target(self.bmp)
		camera() -- to do: should camera get reset the same way as clipping?
		
		-- grab instrument attributes
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + node_index*0x20
		local node_type = peek(node_addr+1) & 0xf
		local wave_addr = node_addr + 4 + 4*4
		local wave_val  = peek(wave_addr+1)
		
		-- wavetable
		local wt_index = (peek(node_addr+1)>>4)
		local wt_addr = el.addr + wt_index * 4
		local addr0, addr1, width_bits, wt_height = peek(wt_addr,4)
		local dat_addr = (addr0 << 8) | (addr1 << 16)
		local wt_width = 1 << width_bits
		
		dat_addr += (wave_val * wt_height >> 8) * wt_width*2
		
		local phase_addr = node_addr + 4 + 5*4
		local phase_val  = (peek(phase_addr+1) + 128) % 256 - 128
	
		local stretch_addr = node_addr + 4 + 5*4
		local stretch_val  = 0--peek(stretch_addr+1)
		
		if (stretch_val >= 128) stretch_val -= 256
		stretch_val = (stretch_val + 128) / 128 -- 0..2
		
	
		local vol_addr = node_addr + 4 + 0*4
		local vol_val  = peek(vol_addr+1)
		
		-- decide when to redraw scope;
		-- at least 8pfs, or every frame when mouse is down
		local refresh_scope =  msg.mb > 0 or self.dither_t==node_index
		if (self.refresh) refresh_scope = true self.refresh = false
		if (self.sy>270 or self.sy < -h) refresh_scope = false -- not visible
		--
		
		if (refresh_scope) self.bmp:clear()
		
		if (not refresh_scope) then
			-- nothing happening (mouse button up): update 4fps
			
		elseif (node_type == 2 and not something_is_playing) then
			-- osc when nothing is playing: visualise waveform
			line()
			self.bmp:clear()
			--for i = self.dither_t, self.width-1, 4 do
			for i = 0, self.width-1,.5 do
			
				local samx = i / self.width
				samx += phase_val/256
				samx = (samx * stretch_val) % 1
				
				local i2 = flr(samx * wt_width)
				local val = peek2(dat_addr + i2*2)
				val *= (vol_val/0x40)
				
				local xx = i
				local yy = self.height/2 - val * self.height/72000
				--line(xx,yy,11)
				pset(xx,yy, pget(xx,yy) == 3 and 11 or 3)
				--poke(0x540a,0,0)
				--line(xx,0,xx,h,0)
				--pset(xx,yy,11)
			end
			
			print("wt-"..wt_index,2,2,3)
		elseif (node_type == 8) then
			local low    = peek(node_addr + 4 + 0*4 + 1) / 255.0
			local high   = peek(node_addr + 4 + 1*4 + 1) / 255.0
			local res    = peek(node_addr + 4 + 2*4 + 1) / 255.0
			
			-- to do: calculate cutoff in Hz or something?
	
		elseif (node_type == 9) then
			local delay   = peek(node_addr + 4 + 0*4 + 1)
			local vol     = peek(node_addr + 4 + 1*4 + 1) / 255.0
			local ww = self.width \ 7
			local hh = self.height - 4
			for i=0,6 do
				 local xx=2+ww*i
				 rectfill(xx+1,self.height-2,xx+ww-2,self.height-2-hh,12)
				 hh *= vol
			end
		elseif (node_type == 10) then
		
			local gain  = peek(node_addr + 4 + 0*4 + 1) * 7.0 / 255.0
			gain = 1.0 + gain * get_mval_scale(node_addr + 4 + 3)
			
			local elbow = peek(node_addr + 4 + 1*4 + 1) / 255.0
			elbow *= get_mval_scale(node_addr + 4 + 1*4 + 3)
			
			local cut   = 1.0 - peek(node_addr + 4 + 2*4 + 1) / 255.0
			local mix   = peek(node_addr + 4 + 3*4 + 1)
			local ww = self.width
			local hh = self.height
			
			
			fillp(0x5555)
			line(0, hh - cut * hh, ww, hh - cut * hh, 13)
			fillp()
			
			local elbow_y = cut
			local elbow_x = elbow_y / gain
			local slope = 0
			
			if (elbow_x == 1.0) then
				slope = 0
			elseif (elbow < 0.5) then
			
				local tt = elbow * 2
				local slope0 = (gain-elbow_y) / (1-elbow_x)
				local slope1 = (1-elbow_y) / (1-elbow_x)
				slope = (1-tt) * slope0 + (tt * slope1)
			else
				local tt = (elbow-.5)*2
				local slope0 = (1-elbow_y) / (1-elbow_x)
				slope = (1-tt) * slope0
			end
			
			for i = 0,self.width-1, .5 do
				local tt = i / self.width
				local val=0
				
				if tt < elbow_x then
					val = tt*gain
				else
					if elbow < 1 then
						val = elbow_y + (tt-elbow_x)*slope
					else
						-- foldback \m/
						local e2 = elbow-1
						local h2 = elbow_y / 2
						--val = h2 + cos((tt-elbow_x)*e2) * h2
						-- 0.1.0h: linear reflection
						val = ((tt-elbow_x)*e2)%1
						val = ((val < 0.5) and 1-val*4 or -1 + (val-0.5)*4)
						val = h2 + val * h2
					end
				end
				
				local xx = i
				local yy = self.height - val * self.height
			
				pset(xx,yy, pget(xx,yy) == 3 and 11 or 3)
			end
		else
			
			--------- live output ----------
			
			ci_channel = 8 -- ** assume channel 0
			
			if (ci_channel < 0) return -- don't know which channel [yet?] -- skip
			
			-- tick_len is never larger than 4k
			local tick_addr = 0x200000 + node_index * 8192
			
			local tick_len = stat(400 + ci_channel, 8)
	
			-- grab at 15fps (perf + so is readble)
			--if ((global_t + node_index) & 3 == 0 and (not msg.has_pointer or msg.mb==0)) 
			if (true)
			then
				tick_len = stat(400 + ci_channel, 20 + node_index, tick_addr)
			end
			
			for i = 0,self.width-1 do
				local i2 = i\.5 -- 2 samples per pixel
				local val = peek2(tick_addr + i2*2)
				local yy = self.height/2 - val * self.height/72000
				--pset(i,yy, pget(i,yy) == 3 and 11 or 3)
				pset(i,yy,11)
			end
		end
		
		set_draw_target()
		blit(self.bmp,nil,0,0,self.sx,self.sy)
		
	end
	return el
end	


function create_muted_node_toggle(addr,x,y)
	local el = { 
		addr = addr,
		x = x, y = y, width = 7, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & 0x2
		clip()
		pal(7,1)
		spr((val & 0x2 > 0) and 57 or 56,0,0+yy)
		pal()
	end
	function el:tap()
		checkpoint()
		local val = peek(self.addr)
		val ^^= 0x2
		poke(self.addr, val)
		--refresh_gui = true
	end
	
	return el
end


function delete_node(index)
	local tr = read_node_tree(0x40000 + ci*0x200, 0, nil)
	checkpoint()
	-- op here
	local n, i = get_node_by_index(index, tr)
	local p = n.parent
	deli(p.child, i)
	
	-- write back out
	memset(0x40000 + ci*0x200, 0, 0x20 * 8)
	write_node_tree(0x40000 + ci*0x200, tr, 0, 0)
	refresh_gui = true
end


function create_child_node(parent_index, node_type, is_modulator, copy_from_parent)

	if (peek(0x40000 + ci*0x200 + 7 * 0x20 + 1) > 0) then
		notify("too many nodes (max: 8)")
		return
	end
	
	local tr = read_node_tree(0x40000 + ci*0x200, 0, nil)
	checkpoint()
	
	
	local p = get_node_by_index(parent_index, tr)
	
	-- create node item with default data
	
	local n = { content = userdata("u8",0x20), parent = p, child = {} }
	-- dummy; parent index is calculated at end when writing out tree
	local parent_index = p.index
	
	if (node_type == 0x2 and is_modulator) then
		set(n.content, 0,
			parent_index | 16,
			node_type, 0, 0,
			0x0,0x20,0,0,  -- volume:absolute
			0x0,0,0,0,     -- pan:  not used
			0x1,0,0,0,     -- tune: parent+0 -- not quantized
			0x1,0,0,0,     -- bend: parent+0
			0,0,0,0,       -- waveform
			0x0,0,0,0      -- phase
		)
	elseif (node_type == 0x2) then
		set(n.content, 0,
			parent_index, node_type, 0, 0,
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:  parent+0
			0x21,0,0,0,    -- tune: parent+0   0x20 quantized;
			0x1,0,0,0,     -- bend: parent+0
			0,0,0,0,       -- waveform
			0x0,0,0,0      -- phase
		)
		
	else
		-- fx: no parent ops
		set(n.content, 0,
			parent_index, node_type, 0, 0
			-- all zero: fx knobs are all uint8, so don't need 0x8 flags set
		)
		-- ..except for fx:filter
		set(n.content, 4+2*4, 0x2)
	end
	
	-- copy data from parent when both are osc
	if (copy_from_parent) then
		set(n.content, 4,
			peek(0x40000 + ci*0x200 + parent_index*0x20 + 4, 28)
		)
	end
	
	-- add it to tree (at end of children) and write tree back out
	add(p.child, n)
	
	memset(0x40000 + ci*0x200, 0, 0x20 * 8)
	write_node_tree(0x40000 + ci*0x200, tr, 0, 0)
	refresh_gui = true
	
end


local node_op_str={
	[0]="carrier","fm mod","ring mod", "xor","or"
}
function create_op_toggle(addr,x,y)
	local el = { 
		addr = addr, cursor="pointer",
		x = x, y = y, width = 40, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) >> 4
		clip()
		pal(7,1)
		rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 6)--6+val*3)
		--spr(val,1,1+yy)
		print(node_op_str[val],2,1+yy,1)
		pal()
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr) >> 4
		if (val > 0) then
			val = val == 1 and 2 or 1
			poke(self.addr, (peek(self.addr) & 0xf) | (val << 4))
		end
		--refresh_gui = true
	end
	
	return el
end

local node_fx_str={
	[8]="filter",[9]="echo",[10]="shape", [11]="crush"
}
function create_fx_type_toggle(addr,x,y)
	local el = { 
		addr = addr,
		x = x, y = y, width = 40, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & 0xf
		clip()
		pal(7,1)
		rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 6)
		--spr(val,1,1+yy)
		print(node_fx_str[val],2,1+yy,1)
		pal()
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr)
		val = 8 + (((val-8) + 1) % 3) -- only need filter, echo, gain
		poke(self.addr, (peek(self.addr) & 0xf0) | (val & 0x0f))
		refresh_gui = true
		
		-- reset parent operator bits to defaults (0 except for FX:FILTER:RES)
		for i=0,6 do
			local mval_addr = self.addr + 3 + i*4 -- first byte of mval (flags)
			poke(mval_addr, peek(mval_addr) & ~0x03) -- strip low 2 bits (op)
			-- only FX:FILTER:RES (type 8, node 2) has MF_MUL_PARENT set
			if (i == 2 and val == 8) poke(mval_addr,peek(mval_addr) | 0x2)
		end
	end
	
	return el
end


local node_type_str={
[0]="none", "","osc:","alias", -- root has no label -- put instrument name there
"","","","",
"fx:","fx:","fx:","fx:"
}

local mval_dat = {
	{"vol","pan","tune","bend","p0","p1"},
	{"vol","pan","tune","bend","wave","phase"},
	nil,
	nil,nil,nil,nil,
	-- really want fx boxes to be tiny and specialized
	-- (and to cost nodes! -- they are generally expensive on host)
	-- to do: standard "clip" for all fx nodes
	-- 0..127 means clip to max..osc_vol  128..255 means clip to osc_vol..0
	{"low","high","res"},
	{"delay","vol"},
	{"gain","elbow","cut","mix"},
	{"resx","resy","lpf"}, -- can adjust the sample rate, sample precision
}

function get_node_by_index(index, tr, childi)
	if (tr.index == index) return tr, childi
	for i=1,#tr.child do
		local res, childi = get_node_by_index(index, tr.child[i], i)
		if (res) then
			return res, childi
		end
	end
	return nil
end


function read_node_tree(addr, index, parent)
	local tr = {parent = parent}
	
	tr.content = userdata("u8", 32)
	tr.index = index -- the original index before transformation
	tr.content:set(0, peek(addr + index * 0x20, 0x20))
	tr.child = {}

	-- add children if they exist
	for i=index+1,7 do
		--printh(" looking for child at i "..i.."  parent:"..peek(addr + i*0x20))
		if (peek(addr + i*0x20) & 0xf) == index -- parent is given index
			and peek(addr + i*0x20 + 1)&0xf > 0 -- non-empty node
		then
			add(tr.child, read_node_tree(addr, i, tr))
		end
	end	

	return tr
end

function write_node_tree(addr, tr, index, parent_index)
	if (tr.content[1] & 0xf == 0) return index -- type:none
	if (index >= 8) return index -- safety: too many nodes
	
	--printh("writing node "..index.." content:"..pod(tr.content,0))
	
	poke(addr + index * 0x20, get(tr.content))
	
	-- update parent index. (everything else is the same)
	poke(addr + index * 0x20,
		(peek(addr + index * 0x20) & 0xf0) | parent_index)
	
	local child_parent = index
	index += 1
	for i=1,#tr.child do
		index = write_node_tree(addr, tr.child[i], index, child_parent)
	end			
	return index
end

function print_node_tree(tr, depth)
	printh(depth.." @ "..tr.index.." "..pod(tr.content))
	for i=1,#tr.child do
		print_node_tree(tr.child[i],depth+1)
	end
end
	
-- read everyhting into a tree, modify the tree, then write back out.
function swap_node_branches(n0, n1)
	local tr = read_node_tree(0x40000 + ci*0x200, 0, nil)
	
	

	-- check can write back same as read in	
	-- if (1) write_node_tree(0x40000 + ci*0x200, tr, 0, 0) return
	
	local n0, i0 = get_node_by_index(n0, tr)
	local n1, i1 = get_node_by_index(n1, tr)
	
	if (not n0 or not n1) printh("@@@ could not find nodes") return
	
	local p = n0.parent
	
	checkpoint()
	--printh("before swap") print_node_tree(tr, 0)
	
	p.child[i0], p.child[i1] = p.child[i1], p.child[i0]
	
	-- printh("after swap") print_node_tree(tr, 0)
	memset(0x40000 + ci*0x200, 0, 0x20 * 8)
	write_node_tree(0x40000 + ci*0x200, tr, 0, 0)

	refresh_gui = true
end


function move_sibling_node(index, dir)
	
	if (dir == 0) then
		-- check there is another sibling at same level
		for i=1,7 do
			if i ~= index and node_parent_index[i] == node_parent_index[index]
			then
				return true -- some siblings
			end
		end
		return false -- no need for sibling shuffle button
	end
	
	local target = -1
	if dir < 0 then
		-- find previous sibling
		for i = index-1,1,-1 do
			if (node_depth[i] == node_depth[index] and target == -1) target = i
		end
	else
		-- find next sibling
		for i = index+1, 7 do
			if (node_depth[i] == node_depth[index] and target == -1) target = i
		end
	end
	
	if (target == -1) return -- couldn't move
	
	-- swap siblings
	swap_node_branches(target, index)
	
end

function create_node_editor(parent, node_index, x, y, depth)

	local inst_addr = 0x40000 + ci*0x200
	local node_addr = inst_addr + node_index*0x20
	local node_type = peek(node_addr+1) & 0xf
	local node_op = peek(node_addr) >> 4
	
	local labels = mval_dat[node_type] or {}
	
	local width = 240
	
	local rows = 3
	if (node_type == 1) rows=2
	if (node_type >= 8) rows=2 --width = 118
	
	local height = 20 + rows * 16
	
	
	
	local desc = node_type_str[node_type] or "??"
	if (desc == "") desc = string.format("%02x", ci)
	--if (node_type == 2) desc ..= " "..(node_op_str[node_op] or "??")
	
	local head_col = node_type_col[node_type]
	if (node_type == 2 and node_op > 0) head_col = 0xd05

	local el = parent:attach(create_pane("  "..desc, x, y, width, height, head_col))
		
	-- active / not active toggle
	el:attach(create_muted_node_toggle(node_addr+2, 3,1))
	
	-- operator button for oscillator children
	if (node_type == 2) then
		el:attach(create_op_toggle(node_addr, 34,1))
	end
	
	if (node_type >= 8) then
		el:attach(create_fx_type_toggle(node_addr+1, 30,1))
	end
	
	
	-- child creation buttons for oscillators / root
	if (node_type < 4) then
		local xx=el.width-72 
		if (node_type == 1) xx += 30
		if (node_type != 1) xx -= 20 -- not root: make space for sibling order buttons
		
		if (node_type == 2) then -- +mod only for carrier osc
		xx += el:attach{
			x=xx,y=1,width=19,height=7,cursor="pointer",
			draw = function(this,msg)
				rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
				print("+mod",2,1,5)
			end,
			tap = function() create_child_node(node_index,2,true) end
		}.width+2
		end
		xx+=el:attach{
			x=xx,y=1,width=19,height=7,cursor="pointer",
			draw = function(this,msg)
				rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
				print("+osc",2,1,5)
			end,
			tap = function() create_child_node(node_index,2, nil, true) end
		}.width+2
		
		xx+=el:attach{
			x=xx,y=1,width=15,height=7,cursor="pointer",
			draw = function(this,msg)
				rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
				print("+fx",2,1,5)
			end,
			tap = function() create_child_node(node_index,8) end
		}.width+2
	end
	
	if (node_type != 1) then
		-- sibling reordering
		local xx=el.width-30
		
		-- move up
		if (move_sibling_node(node_index,0)) then
			xx += el:attach{
				x=xx,y=1,width=7,height=7,cursor="pointer",
				draw = function(this,msg)
					rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
					print("\^:00040e1f00000000",1,1,13)
				end,
				tap = function() move_sibling_node(node_index, -1) end
			}.width+2
	
			xx += el:attach{
				x=xx,y=1,width=7,height=7,cursor="pointer",
				draw = function(this,msg)
					rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
					print("\^:001f0e0400000000",1,1,13)
				end,
				tap = function() move_sibling_node(node_index, 1) end
			}.width+2
		end
	end
	
	-- delete node
	if (node_type > 1) then
	el:attach{
		x=el.width-10,y=1,width=8,height=7,cursor="pointer",
		draw = function(this,msg)
			rectfill(0,0,this.width,this.height,msg.has_pointer and 8 or 6) 
			print("X",2,1,5)
		end,
		tap = function() delete_node(node_index) end
	}
	end
	
	
	-- knobs
	
	for y=0,rows-1 do for x=0,y==2 and rows-1 or 1 do
		local mval_index = y*2 + x
		local label = labels[mval_index+1] or "??"
		
		-- pan is only shown on depth:1 OSC and root
		if (label == "pan" and (
			depth > 1 or -- anything 2 or deeper does not have a stereo position
			(depth == 1 and node_type ~= 2) or -- only osc can have pan at level 1
			(depth == 1 and peek(inst_addr + 0x1df) & 0x2 == 0) -- stereo not enabled
		)) then
			label = nil -- hide
		end
		
		

		if (mval_index < #labels and label) then
			el:attach(create_mval_knob(label, node_type, mval_index,
				node_addr + 4 + mval_index*4, 26 + x*80, 13 + y*18))
		end
	end end
	
	el:attach(create_scope(inst_addr+0x1e0,node_index,164,14, 69, el.height-19))

	return el
end


function update_instrument_editor()

	-- copy and paste instruments
	if (key"ctrl") then
	
		if keyp("c") or keyp"x" then
			local ud = userdata("u8",0x200 * (ci1-ci0+1)):peek(0x40000+ci0*0x200)
			set_clipboard(pod({
				instrument=ud
			},7,{pod_type="instrument"}))
			if keyp"x" then
				for i=ci0,ci1 do clear_instrument(i) end
				notify("cut "..(ci1-ci0+1).." instruments")
				refresh_gui = true
			else
				notify("copied "..(ci1-ci0+1).." instruments")
			end
		end
		
		if keyp("v") then
			checkpoint()
			local dat = unpod(get_clipboard())
			
			if (dat and type(dat.instrument) == "userdata") then
				dat.instrument:poke(0x40000+ci*0x200)
				notify("pasted "..(#dat \ 0x200).." instruments")
				refresh_gui = true
			else
				notify("could not find instrument data to paste")
			end
		end
	
	end
end



:: main.lua
--[[pod_format="raw",created="2023-10-22 07:30:04",modified="2024-09-12 16:58:56",revision=14222,stored="2023-36-29 04:36:40"]]
--[[
	Picotron Tracker
	(c) Lexaloffle Games LLP
]]

include "data.lua"
include "inst.lua"
include "track.lua"
include "env.lua"
include "gui.lua"
include "update.lua"
include "undo.lua"

include "debug.lua"

function _init()
	
	poke(0x4000, get(fetch"/system/fonts/p8.font"))
	
	window{
		tabbed=true,
		icon = userdata"[gfx]08080077777700700007007000070070000700700777777007777770000000000000[/gfx]",
		title="sfx"
	}
	
	mkdir "/ram/cart/sfx"
	
	wrangle_working_file(
		function()
			local ud = userdata("u8",0x40000)
			for i=0,0x3f do
				set(ud, i * 0x1000, peek(0x30000 + i * 0x1000, 0x1000))
			end
			return ud
		end,
		function (ud)
			if (type(ud)~="userdata") then
				init_data()
			else
				memset(0x30000, 0, 0x40000) -- incase stored short / legacy userdata
				for i=0,0x3f do
					poke(0x30000 + i * 0x1000, get(ud, i * 0x1000, 0x1000))
				end
			end
			tdat={}
			init_undo()
		end,
		"/ram/cart/sfx/0.sfx"
	)
	

	-- current node, instrument, track, pattern
	cn = 0
	ci = 0
	ct = 0
	cp = 0
	
	-- item selection ranges for instruments, tracks, patterns
	ci0,ci1,ci2 = 0,0,0
	ct0,ct1,ct2 = 0,0,0
	cp0,cp1,cp2 = 0,0,0
	
	cvol = 0x20
	coct = 4
	
	mode = "track"
	
	scroll = {} -- scroll position for choosers

	init_undo()
	
end

-- for mocking up
function draw_pane(title, x, y, w, h, col)
	col = col or 5
	y = y + 2
	rectfill(x,y,x+w-1,y+h-1,col)
	rectfill(x,y,x+w-1,y+6,7)
	print(title,x+4,y+1,1)
	
	--pset(x,y,0) pset(x+w-1,y,0)
	--pset(x,y+h-1,0)	pset(x+w-1,y+h-1,0)
end


function draw_node_attr(label, x, y)

--	rectfill(x, y, x+60, y+8, 6)


	rectfill(x+30,y,x+70,y+8,0)

	-- *2.0+1 means *2.0 relative to parent,  +1 semitone
	-- special for tune. click label to toggle between *2.0+1 and +1
	-- other attributes: click label to toggle between 1.0 and *1.0

	if (label == "tune") then
		print("*2.00+1",x+42,y+2, 13)
	else
		print("1.000",x+47,y+2, 13)
	end

	circfill(x+30,y+4,7,0)
	circ    (x+30,y+4,7,7)
	
	
	print(label, x+2, y+2, 6)

end

function _draw()


	--fillp(1)
	--fillp(~0x813d)
	fillp(~0x8239) -- brushed metal? something industrial
	rectfill(0,0,480,270,32 | (33*256))
	fillp()
	
	--rectfill(368,0,480,270,5)
	--rectfill(0,0,108,270,5)
	
--[[
	draw_pane("song info", 2,2,96,56,1)
	draw_pane("instruments",2,62,96,98,1)
	--draw_pane("mudo state",2,164,96,90,0)
]]
	
	
	-- operations during _update can request a
	-- gui update before it is next draw (avoid flicker)
	if (refresh_gui or not gui) then
		readtext(true) -- clear text input buffer
		generate_gui()
		-- gui:draw_all() expects :update_all() called first on current state of gui
		gui:update_all()
		refresh_gui = false
	end
	
	gui:draw_all()
	
	if (mode == "instrument" and grabbed_envelope) then
		local mx,my,mb=mouse()
		if (mb>0) print("\#7  env-"..grabbed_envelope,mx-3,my,17)	
	end
	
	if (mode != "instrument" and grabbed_track and time()>grabbed_track_t+.25) then
		local mx,my,mb=mouse()
		if (mb>0) then
			
			local sx,sy=mx-20,my-8
			rectfill(sx,sy,sx+39,sy+8,5)
			palt(0)
			spr(get_sfx_thumb(grabbed_track),sx+2,sy+1)
			print("sfx:"..grabbed_track,sx+12,sy+2,11)
			palt()
		end
	end
	
	-- custom display palette
	-- at end.. something in :draw_all() probably calls pal()
	poke4(0x5000+32*4, 0x202020)
	
	--poke4(0x5000+32*4, 0xf020f0) -- debug flashing
	
--	print(string.format("cpu:%3.3f",stat(1)),440,250,7)
--draw_mudo_state(380,200)
	
	
end


:: track.lua
--[[pod_format="raw",created="2023-10-27 18:49:18",modified="2024-09-12 17:23:50",revision=10368]]
--[[

	track editor

]]



function create_tiny_num_field(label,addr,x,y,  vmin, vmax)
	local el={
		x=x,y=y,
		width=15,height=14,
		label=label,addr=addr,
		vmin=vmin, vmax=vmax
	}
	
	function el:draw()
		local val=peek(self.addr)
		if (has_knob) then
			circ(7,5,5,13)
			local aa=.7-val*.9/255.0
			line(7.5+cos(aa),5.5+sin(aa),7.5+cos(aa)*4,5.5+sin(aa)*4,7)
		end
		
		clip()
		
		-- 
		local yy= 0
		rectfill(0,yy,14,yy+6,0)
		local str=tostr(val)
		print(str,14-#str*4,yy+1,3)
		
		local label = self.label
		if (label == "loop0" and peek(self.addr+1) <= val) label = "len"
		print(label,-(2+#label*4),yy+1,6)

	end
	
	function el:click(msg)
		mouselock(0x4|0x8, 0.25, 0.05) -- 0x4 lock 0x8 auto-release, event speed, move speed 
	end
	
	
	function el:drag(msg)
		local val=peek(self.addr)
		val += msg.dx - msg.dy
		local vmin = el.vmin or 0
		local vmax = el.vmax or 255
		
		val = mid(vmin,val,vmax)
		poke(self.addr, val)
	end
	
	return el
end


cur_x = 0
cur_y = 0x50000 + 8

local note_name = {[0]=
"c ","c#","d ","d#","e ","f ","f#","g ","g#","a ","a#","b "
}
local val_to_str_0xff = {}
local val_to_str_0x00 = {}
local val_to_note     = {}

for i=0,255 do
	val_to_str_0xff[i] = string.format("%02x",i) 
	val_to_str_0x00[i] = string.format("%02x",i) 
	val_to_note[i] = note_name[i%12]..(i\12)
end

--val_to_str_0x00[0x00] = ".."
val_to_str_0xff[0xff] = ".."
val_to_note    [0xff] = "..."


local function render_row(addr, stride)
	
	local freq = @addr addr += stride
	local inst = @addr addr += stride
	local vol  = @addr addr += stride
	local fx   = @addr addr += stride
	local fxp  = @addr
	
	-- to do: cpu cost for string.format
	-- could keep a large cache by int64 hash of input
	return string.format("%s\-h\fe%s\-h\fc%s\-h\fd%s\f6%s",
		val_to_note[freq],
		val_to_str_0xff[inst], val_to_str_0xff[vol],
		fx == 0 and "." or chr(fx),
		fx == 0 and ".." or val_to_str_0x00[fxp]
	)
	
end

local function render_selection(x0, x1)
	if (x0 > x1) x0,x1 = x1,x0
	local str=""
	local str1 = "  "
	for i=0,8 do
		if (x0 <= i and x1 >= i) then
			str..= "\^i"..str1.."\^-i"
		else
			str..= str1
		end
		str1 = " " -- subsequent items are a single character
		if (i == 0 or i == 2 or i == 4) str1 ..= "\-h" -- 1px space
	end
	

	return str
--[[
	return string.format("%s%s\-h%s\-h%s\-h%s%s",
		(x0 <= 0 and x1 >= 0) and "\^i  \^-i" or "  ",
		(x0 <= 1 and x1 >= 1) and "\^i \^-i" or " ",
		(x0 <= 2 and x1 >= 2) and "\^i  \^-i"  or "  ",
		(x0 <= 3 and x1 >= 3) and "\^i  \^-i"  or "  ",
		(x0 <= 4 and x1 >= 4) and "\^i \^-i"   or " ",
		(x0 <= 5 and x1 >= 5) and "\^i  \^-i"  or "  "
	)
]]
end

-- by sfx_index; could do by channel later esp
-- if playing same sfx on two diffrent channels
function playing_row(sfx_index)

	if (stat(464)==0) return nil -- nothing playing
	
	for i=0,7 do
		if (stat(400 + i, 12) == sfx_index) then
			--printh("playing_row for sfx "..sfx_index..": "..stat(400 + i, 9))
			return stat(400 + i, 9)
		end
	end
end

function create_track_segment(el)

	local row_h = 8
	
	el.x = el.x or 0
	el.y = el.y or 0
	el.rows    = el.rows or 32
	el.width   = 44 -- always 48
	el.height  = el.height or el.rows * row_h + 2
	el.row0    = el.row0 or 0
	el.index   = el.index or ct -- sfx index
	el.last_index = -1
	el.rowstr={}
	
	
	if (not tdat[el.index]) tdat[el.index] = {}
	local ddat = tdat[el.index] -- decoration data
	
	-- recall per-sfx cursor
	if (ddat.cur) then
		cur_x = ddat.cur.x
		cur_y = ddat.cur.y
	end
	
	--tdat[el.index].sel={x0=0,y0=0,x1=3,y1=5}

	-- e.g. 0x50008 for first element on first row of first track
	-- add + el.row0 to get address of first row in segment	
	local base_addr = 0x50000 + (el.index * 328) + 8
	
	function el:update()
		if (el.live_index) then
			el.index = peek(0x30100 + cp * 20 + el.chan_i)
			base_addr = 0x50000 + (el.index * 328) + 8
			
			-- create default track data when needed
			if (el.index ~= el.last_index) then
				el.last_index = el_index
				local addr = 0x50000 + (el.index * 328)
				if peek8(addr) == 0 and peek8(addr + 8) == 0 then
					init_track(addr)
				end
			end
			
		end
		ddat.cur={x=cur_x,y=cur_y} -- store per-sfx cursor
	end
	

	function el:draw(msg)
	
		local sel = ddat.sel
		
		rectfill(0,0,1000,1000,0)
		
		local y0 = 0
		local y1 = self.rows - 1
		
		y0 = mid(0, (-self.sy)\row_h + 1, self.rows-1)
		y1 = mid(0, y0 + 270\row_h, self.rows-1)
		
		
		
		for i = y0,y1 do
		
			if (i%8 == 0 and self.rows > 8) then
				rectfill(0,i*row_h, self.width-1,i*row_h+row_h, i == 32 and 2 or 21)
			end
			
			if (i + self.row0 == playing_row(el.index)) then
				rectfill(0,i*row_h, self.width-1,i*row_h+row_h, 18)
			end
			
			-- note(3) inst(2) vol(2) effect(3)
			
			--print("c 3\-h\fe..\-h\fc..\-h\fd..0", 1, 1+i*7, 6)
			
			-- selected (only when viewing current track)
			if el.index == ct then
			
				if sel then
					local x0,y0,x1,y1 = get_track_selection(sel)
					if i + el.row0 >= y0 and  i + el.row0 <= y1 then 
						print(render_selection(x0, x1), 1, 1+i*row_h, 10)
					end
				end
				
				-- single
				--[[ don't need -- single-cel selection always follows cursor now
				if (cur_y == base_addr + i + el.row0) then
					print(render_selection(cur_x, cur_x), 1, 1+i*row_h, 9)
				end
				]]
			end
			
			print(render_row(base_addr + i + el.row0, 64), 1, 2+i*row_h, 6)
			
		end
		
		--rectfill(43,0,45,self.rows*7-3,16)
		
		-- light up when tragging a track index over track segment
		-- (drop to assign track to pattern channel)
		if (self.drop_track_index and
			msg.mx>=0 and msg.mx <self.width and msg.my >= 0 and grabbed_track) then
			rect(0,0,self.width-1,self.height-1, 10)
		end
		
	end
	
	function el:click(msg)
	
		focus = "track"
		checkpoint()
		
		local i=(msg.my-2)\row_h
		cur_y = base_addr + i + el.row0
		ct = el.index
		
		--	printh(string.format("base_addr: %x i: %d", base_addr, i))
		
		local col_x = {[0]=0,8,13,17,22,26,31,35,39}
		for i=0,8 do
			if (msg.mx >= col_x[i]) cur_x = i
		end

		if (key"ctrl" and false) then
		
			--  search replace	

		elseif (msg.mb == 2) then
		
			-- pick up instrument
			if (cur_x>=3 and cur_x<=4 and peek(cur_y+64) ~= 0xff) ci = peek(cur_y+64)
			
			-- pick up volume
			if (cur_x>=5 and cur_x<=6 and peek(cur_y+128) ~= 0xff) cvol = peek(cur_y+128)
			
			-- start new selection
			ddat.sel = {
				x0=cur_x, y0=i + el.row0, 
				x1=cur_x, y1=i + el.row0
			}

		elseif (key"shift") then
			-- extend selection
			ddat.sel=ddat.sel or {x0=cur_x, y0=i + el.row0, x1=cur_x, y1=i + el.row0}
			ddat.sel.x1 = cur_x
			ddat.sel.y1 = i + el.row0
		else
			-- start new selection
			ddat.sel = {
				x0=cur_x, y0=i + el.row0, 
				x1=cur_x, y1=i + el.row0
			}
		end
		
		return true -- don't pass through to pane
	end
	
	function el:drag(msg)
		local i=(msg.my-2)\row_h
		cur_y = base_addr + i + el.row0
		local col_x = {[0]=0,8,13,17,22,26,31,35,39}
		for i=0,8 do
			if (msg.mx >= col_x[i]) cur_x = i
		end
		ddat.sel.x1 = cur_x
		ddat.sel.y1 = i + el.row0
	end
	
	-- if track is zeroed, set up default track value
	local addr = 0x50000 + (el.index * 328)
	if peek8(addr) == 0 and peek8(addr + 8) == 0 then
		-- can assume points to zeroed ram --> initialise
		init_track(addr)
	end
	
	return el
end


-- doodle pitch values
-- shift to paint only instrument
function create_pitch_scribbler(el)
	el.index 	= el.index or ct
	el.click 	= checkpoint
	local y_offset = 12
	function el:draw()
		line(0,self.height-1,self.width,self.height-1,1)
		for i=0,63 do
			local val = (@(el.addr + i))
			if (val ~= 0xff) then
				local xx = i * 6
				local inst = @(el.addr + i + el.stride)
				local yy = el.height - val - 1 + y_offset
				rectfill(xx+1, yy, xx + 4, el.height, i==playing_row(el.index) and 12 or 1)
				rectfill(xx+1, yy, xx + 4, yy+1 , 8 + inst%24)
			end
		end
		local track_addr = 0x50000 + ct * 328
		local xx = peek(track_addr+3)*6
		if (xx>0) line(xx,0,xx,self.height,12)
		local xx1 = peek(track_addr+4)*6
		if (xx1>xx) line(xx1,0,xx1,self.height,14)
	end
	
	function el:drag(msg)
		local xx  = mid(0, msg.mx \ 6, 63)
		local val = mid(0, el.height - msg.my + y_offset, 255)
		
		if (msg.mb == 2) then
			ci = peek(el.addr + xx + el.stride)
		else
			-- set instrument
			poke(el.addr + xx + el.stride, ci)
			
			-- set pitch [and volume] only when shift is not held
			if not key"shift" then
				poke(el.addr + xx, val)
				local vol_addr = el.addr + xx + el.stride*2
				if (@vol_addr == 0xff) poke(vol_addr, 32) -- set volume when undefined
			end
		end
	end
	
	return el
end


-- dupe
function create_volume_scribbler(el)
	el.index 	= el.index or ct
	el.click  	= checkpoint
	function el:draw()
		line(0,self.height-1,self.width,self.height-1,1)
		for i=0,63 do
			local val = @(el.addr + i)
			if (val ~= 0xff) then
			local xx = i * 6
			local yy = el.height - val - 1
			rect(xx+1, yy, xx + 4, yy, i==playing_row(el.index) and 7 or 12)
			end
		end
	end
	
	function el:drag(msg)
		local xx  = mid(0, msg.mx \ 6, 63)
		local val = mid(0, el.height - msg.my, 99)
		poke(el.addr + xx, val)
	end
	
	return el
end

function get_track_selection(sel)
	local x0,y0,x1,y1 = sel.x0, sel.y0, sel.x1, sel.y1
	if y0 > y1 or (y0 == y1 and x0 > x1) then
		x0,y0,x1,y1 = x1,y1,x0,y0
	end
	return x0,y0,x1,y1
end

function get_track_selection_size(tdat)
	if (not tdat) return 0
	if (not tdat.sel) return 0
	local sel = tdat.sel
	local x0,y0,x1,y1 = get_track_selection(sel)
	return max(x0-x1, y0-y1)
end



local fx_input = {
	["0"] = "\0", ["."] = "\0",
	["1"] = "s", s="s",
	["2"] = "v", v="v",
	["3"] = "-", ["-"] = "-", 
	["4"] = "<", ["<"] = "<", 
	["5"] = ">", [">"] = ">", 
	["6"] = "a", ["a"] = "a", 
	["7"] = "b", ["b"] = "b", 
	["8"] = "t", ["t"] = "t",
	["9"] = "+", ["+"] = "+",
	w = "w", 
	r = "r", c = "c", d = "d", 
	p = "p"
}

function clear_notes(addr0, addr1, x0, x1)
	x0 = x0 or 0
	x1 = x1 or 9
	for addr=addr0, addr1 do
		if (x0<=1) poke(addr,0xff)
		if (x0<=3 and x1>=2) poke(addr+64,0xff)
		if (x0<=5 and x1>=4) poke(addr+128,0xff)
		if (x0<=6 and x1>=6) poke(addr+192,0)
		if (x0<=8 and x1>=7) poke(addr+256,0)				
	end
end


function update_track_editor()	
	
	local row0_addr = 0x50000 + (ct * 328) + 8
	local stride = 64
	local max_addr = row0_addr + 63
	
	local last_cur_x, last_cur_y = cur_x, cur_y
	local entered_fx = false
	
	
	-- can play even when cursor is not in range
	if (keyp("space") and mode == "track") then
		if (something_is_playing) then
			-- stop all audio when something was playing
			note()
		else
		
			local start_row = 0
			-- to do: setting to play from cursor instead of group of 8
			if (key"shift") then
				-- safety; condition always true
				if (cur_y > row0_addr) start_row = (cur_y-row0_addr) & ~0x7
			end
			
			-- play on channel 0
			sfx(ct, 0, start_row, 0)
			
		end
	end
	
	-- select
	
	if (key("ctrl") and keyp("a")) then
		checkpoint()
		tdat[ct].sel = {x0=0,y0=0,x1=8,y1=63}
	end
	
	-- paste notes
	if key("ctrl") and keyp("v") then
		checkpoint()
		local dat = unpod(get_clipboard())
		if (dat and type(dat.notes) == "userdata") then
			local x0=tonum(dat.x0) or 0
			local x1=tonum(dat.x1) or 8
			local maxy = min(dat.notes:height()-1, 63-(cur_y-row0_addr))
			--notify(string.format("pasting %d %d %d",x0, x1, maxy))
			notify("pasted "..(maxy+1).." notes")
			for y=0,maxy do
				if (x0<=1) poke(cur_y+y,dat.notes:get(0,y))
				if (x0<=3 and x1>=2) poke(cur_y+y+64,dat.notes:get(1,y))
				if (x0<=5 and x1>=4) poke(cur_y+y+128,dat.notes:get(2,y))
				if (x0<=6 and x1>=6) poke(cur_y+y+192,dat.notes:get(3,y))
				if (x0<=8 and x1>=7) poke(cur_y+y+256,dat.notes:get(4,y))
			end
		elseif dat and type(dat.sfx) == "userdata" then
			dat.sfx:poke(0x50000 + ct0*328)
			sfx_thumb={} -- invalidate thumbs
			notify("pasted "..(#dat.sfx \ 328).. " sfx")
		else
			notify("could not find note data or sfx to paste")
		end
	end
	
	-- operations on selections
	
	if (focus == "track_item") then
		-- operations on the sfx
		if (keyp"c" or keyp"x") then
			-- copy a whole sfx (later: multiple sfx can just be longer userdata)
			-- later: variation to support variable length sfx in collection.
			-- avoid needing to decide if "sfxes" (blegh) is plural of sfx
			
			set_clipboard(pod({
				sfx = userdata("u8",(ct1-ct0+1)*328):peek(0x50000+ct0*328)
			},0x7,{pod_type="sfx"}))
			
			if (keyp"x") then
				-- clear
				for i=ct0, ct1 do
					clear_notes(0x50000+i*328+8,0x50000+i*328+8+63)
				end
				clear_notes(row0_addr+0, row0_addr+63)
				notify("cut "..(ct1-ct0+1).." sfx")
				sfx_thumb={}
			else
				notify("copied "..(ct1-ct0+1).." sfx")
			end
		
		end
	elseif (tdat[ct] and tdat[ct].sel) then
	
		local sel = tdat[ct].sel
		local x0,y0,x1,y1 = get_track_selection(tdat[ct].sel)
		local did_cut = false
		
		if (x0~=x1 or y0~=y1) then
			-- some operations shouldn't apply to single cel (deselect / delete)	
			
			-- remove selection
			if (keyp("enter")) then
				if (tdat[ct]) tdat[ct].sel = nil 
				tdat[ct].sel = {
					x0=cur_x, y0=cur_y - row0_addr,
					x1=cur_x, y1=cur_y - row0_addr
				}
				clear_key("enter") -- don't insert a line
			end
		
			-- clear (also use after cutting) -- 
			-- to do: allow clearing at the nibble level
			if (keyp("backspace") or keyp("delete") or did_cut) then
				checkpoint()
				clear_notes(row0_addr+y0, row0_addr+y1, x0, x1)
			end
			
		end
		
		-- copy note data (can do on single cel selection too)
		-- always all vals but record range to write on paste
		if key("ctrl") and (keyp("x") or keyp("c")) then
			did_cut = keyp("x")
			local ud = userdata("u8",5,y1-y0+1)
			for x=0,4 do
				for y=y0,y1 do
					ud:set(x,y-y0,peek(row0_addr+x*64+y))
				end
			end
			set_clipboard(pod({
				notes=ud,
				x0=x0, x1=x1
			},7,{pod_type="notes"}))
			notify("copied "..(y1-y0+1).." notes ")
			--notify("copied "..(y1-y0+1).." notes "..pod{x0,x1,y0,y1}) -- debug
		end
			
			
		--------------------------------------
		--[[
		if (x0~=x1 or y0~=y1) -- let single-cel selection pass through
		and not key"shift"    -- not trying to change size of selection
		then
			readtext(true) -- discard any leftover keypresses
			return
		end
		]]
		--------------------------------------
	end
	
	-- to do: cur_y per track
	-- cursor isn't in current track; don't allow editing
	
	if (cur_y < row0_addr or cur_y >= row0_addr + 64) then
	
		readtext(true) -- consume (and ignore) any text entry

		--------------------------------------
		return	 
		--------------------------------------
	end
	

	
	if key"ctrl" then
	
		readtext(true) -- clear buffer
		
		--------------------------------------
		return -- nothing else to process
		--------------------------------------
	end
	
	
	if (keyp("left"))  cur_x -= 1
	if (keyp("right")) cur_x += 1
	if (keyp("up"))    cur_y -= 1
	if (keyp("down"))  cur_y += 1
	if (keyp("pageup"))    cur_y -= 4
	if (keyp("pagedown"))  cur_y += 4
	
	
	
--[[
	to do: how to handle limits? track vs pattern
	while (cur_y <  0x50008+ct*328+00) cur_y += 64
	while (cur_y >= 0x50008+ct*328+64) cur_y -= 64
]]
	

	
	
	-- going over side means diffrent things depending on layout
	if (mode == "track") then
		if (cur_x > 8) then
			cur_x = 0
			cur_y += 8
		end
		if (cur_x < 0) then
			cur_x = 8
			cur_y -= 8
		end
	end
	
	if (mode == "pattern") then
		-- jump to right
		-- 1. find out current
		local pats = 0x30100 + cp * 20
		local chani = nil
		local i0,i1 = nil,nil
		if (cur_x > 8) i0,i1=0,7
		if (cur_x < 0) i0,i1=7,0
		
		if (i0) then
			for i=i0,i1,sgn(i1-i0) do
				if (peek(pats+i) == ct) then
					chani = i
				elseif chani and ((peek(pats+9) & (1 << i)) > 0) then
					cur_y -= ct * 328
					ct = peek(pats+i)
					cur_y += ct * 328
					cur_x %= 9
					row0_addr = 0x50000 + (ct * 328) + 8
					
					tdat[ct] = tdat[ct] or {}
					tdat[ct].sel = {
						x0=cur_x, y0=cur_y - row0_addr,
						x1=cur_x, y1=cur_y - row0_addr
					}
					last_cur_x = cur_x
					last_cur_y = cur_y
					
--					track_seg_el[i]:set_keyboard_focus(true) -- test
--					refresh_gui = true -- not needed, but why does it break kbd input?
					
					return
				end
			end
			cur_x = mid(0,cur_x,8) -- stop moving
		end
		
	end

	-- in any case: wrap
	cur_x %= 9
	
	-- enter data
	
	local q = 64 -- stride
	
	-- key_pitch: use scancodes rather than textinput
	
	if (cur_x == 0) then
		for i=1,#key_pitch do
			if keyp(sub(key_pitch,i,i)) then
				checkpoint()
				poke(cur_y, 35+i + (coct*12-48))
				if (peek(cur_y+q)   == 0xff) poke(cur_y + q,   ci)   -- set inst
				if (peek(cur_y+q*2) == 0xff) poke(cur_y + q*2, cvol) -- set volume
				
				-- play the track from that note
				sfx(ct, 0, cur_y-row0_addr, 1)
				cur_y += 1
			end
		end
	end
	
	if (keyp("del") or (keyp("backspace") and cur_y > row0_addr)) then
		checkpoint()
		if (keyp("backspace")) cur_y -= 1
		for addr = cur_y, max_addr-1 do
			for j=0,4 do
				poke(addr + j*stride, peek(addr+j*stride+1))
			end
		end
		for j=0,4 do
			poke(max_addr + j * stride, j > 2 and 0 or 0xff) -- blank last line
		end
	end
	
	if (keyp("enter") and cur_y < max_addr and get_track_selection_size(tdat[ct]) < 2) then
		checkpoint()
		for addr = max_addr, cur_y+1, -1 do
			for j=0,4 do
				poke(addr + j*stride, peek(addr+j*stride-1))
			end
		end
		for j=0,4 do
			poke(cur_y + j * stride, j > 2 and 0 or 0xff) -- blank current line
		end
		cur_y += 1
	end
	
	-----
	
	while peektext() do
	
		local c = readtext()
	
		-- checkpoint() -- too agressive!
			
		-- fx
		if (cur_x == 6) then
			
			-- to do: map P8 numbers to chars.
			-- table can also be used to check is a valid effect char
			
			if (fx_input[c]) then
				checkpoint()
				poke(cur_y + q*3, ord(fx_input[c]))
				cur_y += 1
				entered_fx = true
			else
				--notify("effect not found") -- could be " " to play
			end
		else

			local num = nil
			
			if (c >= "a" and c <= "f") num = 10 + ord(c) - ord("a")
			if (c >= "A" and c <= "F") num = 10 + ord(c) - ord("A")
			if (c >= "0" and c <= "9") num = 00 + ord(c) - ord("0")
			
			if (num) then
				checkpoint()
				if (cur_x == 1) poke(cur_y, num*12 + peek(cur_y) % 12)
		
				if (cur_x >= 2 and cur_x <= 3 and peek(cur_y+q) == 0xff) poke(cur_y+q,0)
				if (cur_x == 2) poke(cur_y + q, peek(cur_y + q) % 16 + num * 16)
				if (cur_x == 3) poke(cur_y + q, peek(cur_y + q) &~15 | num )
		
				-- volume
				if (cur_x >= 4 and cur_x <= 5 and peek(cur_y+q*2) == 0xff) poke(cur_y+q*2,0)
				if (cur_x == 4) poke(cur_y + q*2, peek(cur_y + q*2) % 16 + num * 16)
				if (cur_x == 5) poke(cur_y + q*2, peek(cur_y + q*2) &~15 | num )
		
				-- fxp: commented until the mixer can deal with them!
				
				if (cur_x >= 7 and cur_x <= 8 and peek(cur_y+q*4) == 0xff) poke(cur_y+q*4,0)
				if (cur_x == 7) poke(cur_y + q*4, peek(cur_y + q*4) % 16 + num * 16)
				if (cur_x == 8) poke(cur_y + q*4, peek(cur_y + q*4) &~15 | num )
				if (cur_x > 0) cur_y += 1
				
				
				--cur_y += 1
				--if (cur_x > 1) cur_y += 1
			end
			
			-- . button to set whole byte for 
			if (c == ".") then
				checkpoint()
				if (cur_x == 0 or cur_x == 1) poke(cur_y + q*0, 0xff) cur_y += 1
				if (cur_x == 2 or cur_x == 3) poke(cur_y + q*1, 0xff)
				if (cur_x == 4 or cur_x == 5) poke(cur_y + q*2, 0xff)
				--if (cur_x == 6)               poke(cur_y + q*3, 0) -- handled above
				if (cur_x >  6)               poke(cur_y + q*4, 0)
				if (cur_x > 0) cur_y += 1
			end
			
		end
	
	end
	
	-- cursor movement wraps within track
	while (cur_y < row0_addr) cur_y += 64
	while (cur_y >= row0_addr + 64) cur_y -= 64
	
	-- vertical cursor movement in pattern mode: auto-scroll
	if (cur_y ~= last_cur_y and mode == "pattern") then
		local row = cur_y - row0_addr
		
		-- keep cursor within relative row 4,12 (*8 = 32px,96px)
		pattern_contents.y = mid(32 - row * 8, pattern_contents.y, 96 - row*8)
		
		-- clamp
		--pattern_contents.y = mid(0, 64 - row * 8, -- ref: playback following
		pattern_contents.y = mid(0, pattern_contents.y,
			 pattern_contents.parent.height - pattern_contents.height)
	end

	-- cursor movement modifies selection
	
	if tdat[ct] and (cur_x ~= last_cur_x or cur_y ~= last_cur_y)
	then
		
		-- default to selection of last cursor position
		tdat[ct].sel = tdat[ct].sel or
		{
			x0 = last_cur_x, x1 = last_cur_x,
			y0 = last_cur_y - row0_addr,
			y1 = last_cur_y - row0_addr
		}


		if key"shift" and not entered_fx then
			checkpoint()
			-- holding shift (and not for entering an fx like <)
			tdat[ct].sel.x1 = cur_x
			tdat[ct].sel.y1 += (cur_y - last_cur_y)
		else
	
			-- when cursor changes, and selection is a single cel,
			-- move selection with cursor
		
			local x0,y0,x1,y1 = get_track_selection(tdat[ct].sel)
			
			if x0==x1 and y0==y1 then
				tdat[ct].sel={
					x0 = cur_x, x1 = cur_x,
					-- to do: fix awkward change in meaning between cursor / selections
					-- maybe nice that it includes track though
					y0 = tdat[ct].sel.y0 + (cur_y - last_cur_y),
					y1 = tdat[ct].sel.y1 + (cur_y - last_cur_y)
				}
			else
				-- clear selection
				tdat[ct].sel = nil
			end
		end
		
	end
	
	
end

-- applied even when focus is on track
function update_pattern_editor_playback()
	if (keyp("space")) then
		if (something_is_playing) then
			-- stop all audio when something was playing
			note()
		else
			-- to do: hold shift to play from group of 8. 
			-- calculate from cursor track? needs to be handled by mudo_play_pattern()
			music(cp) following_playback = true
		end
	end
end

function update_pattern_editor()

	if ( key"ctrl" and (keyp"c" or keyp"x")) then
		local ud=userdata("u8",20 * (cp1-cp0+1)):peek(0x30100 + cp0*20)
		set_clipboard(pod({
			pattern=ud
		},7,{pod_type="pattern"}))
		
		if key"x" then
			for i=cp0,cp1 do clear_pattern(i) end
			notify("cut "..(cp1-cp0+1).." patterns")
			refresh_gui = true
		else
			notify("copied "..(cp1-cp0+1).." patterns")
		end
	end
	
	if (key"ctrl" and keyp"v") then
		checkpoint()
		local dat = unpod(get_clipboard())
		if (dat and type(dat.pattern) == "userdata") then
			dat.pattern:poke(0x30100 + cp0*20)
			notify("pasted "..(#dat.pattern\20).." patterns")
			refresh_gui = true
		else
			notify("could not paste pattern")
		end
	end
end

:: undo.lua
--[[pod_format="raw",created="2024-03-30 19:03:19",modified="2024-09-12 16:58:56",revision=2205]]
--[[

	single undo stack for whole .sfx file

]]

function init_undo()

	undo_stack = create_undo_stack(
		function()
			local mem = userdata("u8",0x40000):peek(0x30000)
			local ranges = {ci0,ci1,ci2, ct0,ct1,ct2, cp0,cp1,cp2}
			return {mem,tdat,mode,ci,ct,cp,ranges}
		end,
		function(state)
			state[1]:poke(0x30000)
			tdat,mode,ci,ct,cp=state[2],state[3],state[4],state[5],state[6]
			ci0,ci1,ci2, ct0,ct1,ct2, cp0,cp1,cp2 = unpack(state[7])
		end,		
		-- use raw binary encoding suitable for fixed size memory block (same as gfx)
		--> faster encoding,  smaller patches
		0x11 -- (0x1 binary  0x10 pxu raw)
	)
	
end

function checkpoint()
	undo_stack:checkpoint()
end

function undo()
	undo_stack:undo()
	sfx_thumb={} -- invalidate thumbs
	refresh_gui = true
end

function redo()
	undo_stack:redo()
	sfx_thumb={} -- invalidate thumbs
	refresh_gui = true
end
:: update.lua
--[[pod_format="raw",created="2023-10-22 07:32:11",modified="2024-09-12 16:58:56",revision=14024,stored="2023-36-29 04:36:40"]]
global_t = 0

-- map keyboard letters to pitches

key_pitch="zsxdcvgbhnjmq2w3er5t6y7ui9o0p"

something_is_playing = false

function follow_playback(playing_pattern)

	-- click anywhere (e.g. scrollbar) -> turn off following
	local mx,my,mb = mouse()
	if (mb > 0 and last_mb ~= 0) following_playback = false
	if key"left" or key"right" or key"up" or key"down" or
		key"pageup" or key"pagedown"
	then
		following_playback = false
	end
	

	if (not playing_pattern or playing_pattern < 0) following_playback = false
	if (mode ~= "pattern") following_playback = false
	if (not following_playback) return --false
	
	if (cp ~= playing_pattern) then
		cp = playing_pattern
		refresh_gui = true
	else
		-- follow cursor row of leftmost non-looping channel
		
		local row = stat(400 + stat(467), 9)
		pattern_contents.y = mid(0, 64 - row * 8, 
			 pattern_contents.parent.height - pattern_contents.height)
	end
	
end


function _update()


	local playing_pattern = stat(466)

	follow_playback(playing_pattern)
	
	-- find out which channel current instrument is being played on
	ci_channel = -1
	for i=0,15 do
		if (ci_channel == -1 and stat(400+i,1) == ci) then
			ci_channel = i
		end
	end
	
	-- update: something_is_playing
	something_is_playing = false
	for i=0,15 do
		if (stat(400+i,12) != -1) something_is_playing = true -- sfx
		--if (stat(400+i,1 ) != -1) something_is_playing = true -- inst
	end
	
	-- or if there is [recently] some global output (e.g. echo or rogue node)
	len = stat(465,0,0xe0000)
	local found_signal
	for i=0,len-7,8 do
		if (peek8(0xe0000+i) != 0) found_signal = true
	end
	if (found_signal) last_found_signal_t = t()
	if (last_found_signal_t and last_found_signal_t > t()-0.1) then
		something_is_playing = true
	end
	

	if (gui) gui:update_all()
	
	--------------------------------------------
	if (gui and gui:get_keyboard_focus_element()) return
	--------------------------------------------
	
	if (key"ctrl") then
		-- can't play note when holding control
		
		if (keyp"z") undo()
		if (keyp"y") redo()
	
	elseif (keyp"space") then
		-- inst mode only -- track / pat has own handling
		if mode == "instrument" then
			if (something_is_playing) then
				note() -- kill all channels
			else
				-- play current sfx / track
				if (last_mode == "track") sfx(ct)
				if (last_mode == "pattern") music(cp)
			end
		end
	elseif mode == "instrument" then	
		
		local pitch = -1
		--if (keyp("space")) pitch = 48 -- middle c
		if (keyp(",")) pitch = 60 -- to do
		
		for i=1,#key_pitch do
			if key(sub(key_pitch,i,i)) then
				pitch = 35 + i + (coct*12-48)
			end
		end
		
		if (pitch >= 0) then
			note(
				pitch, -- pitch
				pitch ~= last_pitch and ci or 255, -- works with inst retrig flag set
				cvol,    -- volume
				0,0,   -- effect, effect_p
				8,     -- channel index -- 8 so that can play with music
				false  -- don't force retrigger (retrigger when pitch/inst changes)		
				)
		else
			-- release
			local mx,my,mb = mouse()
			if (mb == 0 or mx > 80) -- not holding play button w/ mouse
			then
				note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
			end
		end
		
		last_pitch = pitch
		
	end
	

	if (mode == "track" or (mode == "pattern" and focus == "track")) then
		update_track_editor()
	elseif mode == "pattern" then
		update_pattern_editor()
	elseif mode == "instrument" then
		update_instrument_editor()
	end
	
	-- applies even when focus is on track
	if (mode == "pattern") update_pattern_editor_playback()

	
	-- switch modes
	if (keyp"tab") then
		if (mode == "instrument") then mode = "track"
		elseif (mode == "track") then mode = "pattern"
		else mode = "instrument" end
		set_mode(mode)
	end
	
	-- navigate items
	
	if (cur_x == 6 and (mode == "track" or mode == "pattern")) then
		-- can't navigate when in fx channel!
		-- -,+ mean slide
	elseif (keyp("-") or keyp("+")) then

		local dd = keyp("-") and -1 or 1
		if (mode == "instrument") ci += dd if (key"shift") then extend_instrument_selection() else ci0,ci1,ci2=ci,ci,ci end
		if (mode == "track")      ct += dd if (key"shift") then extend_track_selection()      else ct0,ct1,ct2=ct,ct,ct end
		if (mode == "pattern")    cp += dd if (key"shift") then extend_pattern_selection()    else cp0,cp1,cp2=cp,cp,cp end

		

		refresh_gui = true
	end
	
	
	
	
	global_t += 1
	
	-- consume any leftover text input
	readtext(true)
	
	
end



:: .info.pod
b64$LS1bW3BvZCxub3Rlcz0iKGMpIExleGFsb2ZmbGUgR2FtZXMgTExQIixpY29uPXVzZXJkYXRh
KCJ1OCIsMTYsMTYsIjAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAxMDcwNzA3
MDcwNzA3MDcwNzA3MDcwMTAwMDAwMDAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMDAxMDcw
ZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMDcwNzA3MDcwZDBkMGQwZDBkMGQwZDA3
MDEwMTA3MGQwNzA3MDcwNzBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDA3MGQwNzA3MDcwNzA3MGQw
ZDBkMDcwNzAxMDEwNzBkMDcwNzA3MDcwZDBkMGQwZDA3MGQwNzA3MDEwMTA3MGQwNzA3MGQwZDA3
MGQwZDBkMDcwZDA3MDcwMTAxMDcwZDA3MDcwZDBkMGQwNzBkMGQwZDBkMGQwNzAxMDEwNzBkMGQw
ZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA2MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDYwMTAx
MDYwNjA3MDcwNzA3MDcwNzA3MDcwNzA3MDYwNjAxMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDYw
NjAxMDAwMDAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAx
MDEwMTAxMDAwMDAwIiksYXV0aG9yPSJ6ZXAiLGNyZWF0ZWQ9IjIwMjMtMTAtMTkgMTY6NTA6MDci
LG1vZGlmaWVkPSIyMDI1LTAzLTMxIDE5OjIzOjA2IixyZXZpc2lvbj0wLHJ1bnRpbWU9MTAsdGl0
bGU9IlBpY290cm9uIFRyYWNrZXIiLHZlcnNpb249IjAuMWgiLHdvcmtzcGFjZXM9e3tsb2NhdGlv
bj0ibWFpbi5sdWEjMTQ4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzU1
NyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW5zdC5sdWEjMjc2Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJlbnYubHVhIzIzNCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0idHJhY2subHVhIzEzNiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idXBkYXRl
Lmx1YSM1NiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZGF0YS5sdWEjNzYiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVuZG8ubHVhIzQiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAu
bWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9p
bmRleD00fSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTd9fV1d
:: [eoc]
