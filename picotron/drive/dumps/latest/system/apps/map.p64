picotron cartridge // www.picotron.net
version 2

:: canvas.lua
--[[pod_format="raw",created="2023-04-11 02:04:02",modified="2024-07-18 22:58:53",revision=3395]]

local ww,hh=0,0
local fill_cpu=0
local x0,y0=0,0

--[[
local tile_w = 16
local tile_h = 16
]]

function do_fill_0(bmp, x, y, tc)
	if (get(bmp,x,y) != tc) return
	if (x < 0 or y < 0 or x >= ww or y >= hh) return
	local l,r=x,x
	while(get(bmp,l,y)==tc and l>=0) l-=1
	l+=1
	while(get(bmp,r,y)==tc and r<ww) r+=1
	r-=1
	
	for xx=l,r do
		set(bmp,xx,y,col)	
	end
	
	if (y > 0) then
		local last = nil
		for xx=l,r do
			local val = get(bmp,xx,y-1) == tc
			if (val and not last) then
				do_fill_0(bmp,xx,y-1,tc)
			end
			last = val
		end
	end
	
	if (y < hh-1) then
		local last = nil
		for xx=l,r do
			local val = get(bmp,xx,y+1) == tc
			if (val and not last) then
				do_fill_0(bmp,xx,y+1,tc)
			end
			last = val
		end
	end
	
	-- #putaflipinit
	-- to do: why is this causing wm flicker w/ low values (0.25) ~ how is that possible?
	-- oh.. is just the app gui? need to manually hold frame again after flip. bleh.
	--[[
	if (stat(1) - fill_cpu > 2) then
		fill_cpu = stat(1) gui:draw_all() flip()
		poke(0x547c, 1) -- keep holding frame
	end
	]]
end

function do_fill(bmp, x, y)
	local tc = get(bmp, x, y)
	if (col == tc) return
	ww,hh = bmp:width(), bmp:height()
	fill_cpu = 0
	return do_fill_0(bmp, x, y, tc)
end

-- use pan of current item
-- to do: global pan/scale mode?
local mline = userdata("i16", 4096, 1)

function draw_layer(el, ii, pan_x, pan_y, scale)

	local lbmp = ii.bmp
	if (not lbmp) return
	if (ii.hidden) return
	
	local tile_w = ii.tile_w or 16
	local tile_h = ii.tile_h or 16
	
	local tile_ww = tile_w * scale
	local tile_hh = tile_h * scale

	-- pixel looking at in center
	local ww = (lbmp:width() * tile_w)
	local hh = (lbmp:height() * tile_h)
	local px = ww /2  + pan_x
	local py = hh /2 + pan_y
	
	local x0 = el.width\2  - px * scale
	local y0 = el.height\2 - py * scale
	
		
	local x1,y1 = x0 + ww * scale, y0 + hh * scale
	
	
	-- use for drawing grid lines
	local min_x = mid(0, (0 - x0) \ tile_ww - 1, lbmp:width()-1)
	local min_y = mid(0, (0 - y0) \ tile_hh - 1, lbmp:height()-1)
	local max_x = mid(0, min_x + (el.width \ tile_ww) + 2, lbmp:width()-1)
	local max_y = mid(0, min_y + (el.height \ tile_hh) + 2, lbmp:height()-1)


	if (true) then
	
		map(lbmp,0,0,x0,y0,nil,nil,0, tile_ww, tile_hh)

	-- tline
	--printh((max_x-min_x)*(max_y-min_y))
	--if ((max_x-min_x)*(max_y-min_y) > 2000) then
	elseif (false) then -- testing tline3d
		
		local last_myi = -10000
		for y=0, el.height-1 do
			-- where in map?
			local my = (y - y0) / tile_hh
			if (my >=0 and my < lbmp:height()) then
				if last_myi ~= my\1 then
					last_myi = my\1
					-- if (last_myi>=0 and last_myi<lbmp:height()) 
					if (true) -- should be clipped!
					then
						blit(lbmp,mline,0,last_myi,0,0,lbmp:width(),1) -- copy line
					end
				end
				tline3d(mline,x0,y,x0+ww*scale,y,   0,my%1,lbmp:width(),my%1)
			end
		end

	end

	-- grid lines on current grid (to do: tinted)
	-- don't draw when pressing space in text editor
	if (key("space") and ii == ci and not gui:get_keyboard_focus_element()) then
		fillp() pal()
		--fillp(0xff00)
		for x=min_x*tile_ww,max_x*tile_ww,tile_ww do
			line(x0+x,y0,x0+x,y1-1,0x0201)
		end
	
		--fillp(0x6666)
		for y=min_y*tile_hh,max_y*tile_hh,tile_hh do
			line(x0,y0+y,x1-1,y0+y,0x0201)
		end
		
		fillp()
	end 
	
end


function create_outline(bmp, ww, hh)

	--printh("creating outline: "..pod{ww,hh})

	local out = userdata("u8", ww+2, hh+2) -- 1px boundary
	set_draw_target(out)
	
	sspr(bmp, 0, 0, _, _,1, 1, ww, hh)
	
	ww += 2 hh += 2
	
	local out0 = out:copy()
	
	--out = out:add(out, out, nil, 2) -- whoa!
	-- src_offset, dest_offset, item_width, src_stride, dest_stride, num_items
	out:add(out0, true, ww+1, ww+0, ww-1, ww, ww, hh-2)
	out:add(out0, true, ww+1, ww+2, ww-1, ww, ww, hh-2)
	out:add(out0, true, ww+1, ww*0+1, ww-1, ww, ww, hh-2)
	out:add(out0, true, ww+1, ww*2+1, ww-1, ww, ww, hh-2)
	
	-- disco
	for y=0,hh-1 do
		out:add(8+((y\3)%3)*8, true, 0, y*ww, 4, 0, 8, ww/8+1)
	end
	
	out:add(8, true,  0, 0, ww*4, ww, ww*8, hh/8+1)
	
	set_draw_target()
	return out
end


function udrectfill(ud, x0, y0, x1,y1, col)
	if (type(ud) ~= "userdata") return
	x0\=1 y0\=1 x1\=1 y1\=1
	if (x1<x0)x0,x1=x1,x0
	if (y1<y0)y0,y1=y1,y0
	
	x0 = max(0, x0)
	y0 = max(0, y0)

	local width, height = (x1-x0)+1, (y1-y0)+1
	width = min(width, ud:width()-x0)
	height = min(height, ud:height()-y0)
	
	if (width < 1 or height < 1) return
	
	local udw = ud:width()
	ud:copy(col, true, nil, x0+y0*udw,width, nil,udw,height)
end


function create_canvas(el)
	local ww,hh,x0,y0
	local drag_x0,drag_y0 = 0,0
	
	function el:update(msg)
	
		el.cursor = "crosshair"
		if (mtool == "pan") el.cursor = "grab"
		if (mtool == "fill") el.cursor = icons.bucket_cursor

		-- safety [during dev]
		ci.zoom = item[1].zoom or 1
		ci.pan_x = item[1].pan_x or 0
		ci.pan_y = item[1].pan_y or 0
		
		-- temporary: set layer to size of sprite 0
		-- (later: allow per-layer tile size)
		local spr0 = get_spr(0)
		if (spr0) ci.tile_w, ci.tile_h = spr0:width(), spr0:height()
		

		tile_w = ci.tile_w
		tile_h = ci.tile_h
		ww = cbmp_width  * ci.zoom * tile_w
		hh = cbmp_height * ci.zoom * tile_h

		mtool = ctool
		if (key"space") mtool = "pan"
		if (key"s") mtool = msg.mb and msg.mb > 1 and "pick" or "select"
		
		-- pixel looking at in center
		local px = (cbmp_width * tile_w) /2  + ci.pan_x
		local py = (cbmp_height * tile_h) /2 + ci.pan_y
		
		x0 = el.width\2  - px * ci.zoom
		y0 = el.height\2 - py * ci.zoom
	end
	
	function el:click(msg)
		
		backup_state()

		if mtool == "select" or mtool == "pick" then
			-- needs to happen first for calculating x,y
			clear_selection()
		end


		local x = (msg.mx - x0) \ (ci.zoom * tile_w)
		local y = (msg.my - y0) \ (ci.zoom * tile_h)
		local xx,yy = x,y
		
		if (ci.layer) x-= ci.layer_x y-= ci.layer_y

		-- targe bitmap: draw to floating layer if it exists
		local tbmp = ci.layer or cbmp 
		local tbmp_width, tbmp_height = tbmp:attribs()
		if (type(tbmp)~="userdata") tbmp=cbmp printh("** no tbmp!!")

		drag_x0  = x  drag_y0  = y
		click_x0 = x  click_y0 = y 
		click_xx0 = xx  click_yy0 = yy
		op_bmp = tbmp:copy()
		blit(tbmp, op_bmp) -- to do: remove
		
		if mtool == "fill" and not key"space" and msg.mb == 1 then
			do_fill(tbmp, x, y)
		end
		--[[
		if (mtool == "pick") then
			-- 1x1 selection (dupe)
			
			ci.layer = userdata("i16",1,1)
			ci.layer_x = xx
			ci.layer_y = yy
			ci.layer0 = cbmp:copy()
			ci.layer0:set(xx,yy,0) -- cut out
			-- copy from map to floating layer
			blit(cbmp,ci.layer,xx,yy,0,0,1,1)
		end
		]]
		-- replace
		if (mtool == "pencil" and key"ctrl") then
			local col0 = get(tbmp, x,y)
			for yy=0,tbmp_height-1 do
				for xx=0,tbmp_width-1 do
					if (get(tbmp,xx,yy) == col0) set(tbmp,xx,yy,col)
				end
			end
		end
		
		
	end
	
	
	function el:drag(msg)

		local tbmp = ci.layer or cbmp 
		
		-- set_draw_target(cbmp)
		
		local x = (msg.mx - x0) \ (ci.zoom * tile_w)
		local y = (msg.my - y0) \ (ci.zoom * tile_h)
		local draw_target = ci.bmp
		local xx,yy = x,y
		if (ci.layer) then
			-- set_draw_target(ci.layer)
			draw_target = ci.layer
			x-= ci.layer_x y-= ci.layer_y
		end
		
		if (mtool == "pan" or key"space") then
			--ci.pan_x -= msg.dx / ci.zoom
			--ci.pan_y -= msg.dy / ci.zoom
			item[1].pan_x -= msg.dx / ci.zoom
			item[1].pan_y -= msg.dy / ci.zoom
			
		elseif (mtool == "select") then
			-- xx,yy -- not relative to selection
			set_draw_target(csel)
			rectfill(0,0,1024,1024,0)
			rectfill(click_xx0 +.5, click_yy0 +.5, xx +.5, yy +.5, 1)
			csel_outline = nil -- regenerate
		elseif (mtool == "pick") then
			-- 1x1 selection (dupe)
			
			ci.layer = userdata("i16",1,1)
			ci.layer_x = xx
			ci.layer_y = yy
			ci.layer0 = cbmp:copy()
			ci.layer0:set(xx,yy,0) -- cut out
			-- copy from map to floating layer
			blit(cbmp,ci.layer,xx,yy,0,0,1,1)
		elseif (msg.mb == 2) then
			-- anything after this: mb2 means pick up tile
			col = get(tbmp, x, y)
		elseif (mtool == "pencil" or mtool == "eraser") then
			if (msg.mb == 1) then
				local dx, dy = x-drag_x0, y-drag_y0
				local steps = max(abs(dx),abs(dy))
				dx /= steps dy /= steps
				local xx = drag_x0
				local yy = drag_y0
				
				for i=0,steps do
					set(draw_target, xx, yy, col)
					xx += dx
					yy += dy
				end
			
			end
		elseif mtool == "rect" then
			blit(op_bmp, tbmp)
			udrectfill(tbmp, click_x0 +.5, click_y0 +.5, x +.5, y +.5, col)
		elseif mtool == "stamp" then
			if (last_stamp_bmp_str ~= get_clipboard()) then
				last_stamp_bmp_str = get_clipboard()
				last_stamp_bmp = unpod(last_stamp_bmp_str)
			end
		
			local bmp = last_stamp_bmp
			if (type(bmp) == "userdata") then
				blit(op_bmp, tbmp)
				local ww,hh = bmp:attribs()
				blit(bmp, tbmp, 0, 0, x, y) -- tlc more common; to do: option
				--blit(bmp, tbmp, 0, 0, x - ww/2 + (ww&1)/2, y - hh/2 + (hh&1)/2)
				
			end
			
		elseif mtool == "line" then
			blit(op_bmp, tbmp)
			--line(click_x0 +.5, click_y0 +.5, x +.5, y +.5, col) -- to do -- draw line on tbmp
		end
		
		drag_x0 = x 
		drag_y0 = y
		
		-- update cbmp with any changes drawn to ci.layer
		if (ci.layer) blit(ci.layer, cbmp, 0, 0, ci.layer_x, ci.layer_y)
		
	end

	function el:release(msg)
		
		local x = (msg.mx - x0) \ (ci.zoom * tile_w)
		local y = (msg.my - y0) \ (ci.zoom * tile_h)
		
		if (mtool == "select") then
			if (click_x0 == x and click_y0 == y) then
				-- can't select single tile unless hold for a half a second
				-- deselect
				clear_selection()
			else
				-- create floating layer
				if (x < click_x0) click_x0,x = x,click_x0
				if (y < click_y0) click_y0,y = y,click_y0
				local ww = x - click_x0 + 1
				local hh = y - click_y0 + 1
				
				ci.layer = userdata("i16",ww,hh)
				ci.layer_x = click_x0
				ci.layer_y = click_y0
				
				-- copy of the image 
				ci.layer0 = cbmp:copy()
				-- .. with that area cut out
				udrectfill(ci.layer0, click_x0, click_y0, click_x0 + ww-1, click_y0 + hh-1, 0)

				-- copy from map to floating layer
				blit(cbmp,ci.layer,click_x0, click_y0,0,0,ww,hh)
			end
		end	
		click_x0, click_y0 = nil -- don't draw a selection in progress
	end
	
	function el:draw(msg)
		
		local x = (msg.mx - x0) \ (ci.zoom * tile_w)
		local y = (msg.my - y0) \ (ci.zoom * tile_h)
		
		local scale = ci.zoom
		local tile_ww = tile_w * scale
		local tile_hh = tile_h * scale
		
		
		fillp(0x936c)
		rectfill(0,0,self.width,self.height,1)
		fillp()
		rectfill(x0-1,y0-1,x0+ww,y0+hh,0)
		rect   (x0-2,y0-2,x0+ww+1,y0+hh+1,6)
		
		-- draw bottom to top
		for i=#item,1,-1 do
			draw_layer(el, item[i], item[1].pan_x, item[1].pan_y, item[1].zoom)
		end
		
		
		--[[
		-- tline version: draw a bunch of tlines; clip to viewable area
		-- only works for n^2 map sizes
		local yy0=max(0,0-y0)
		local yy1=min(hh,self.height-y0)-1
		for yy=yy0,yy1 do
			local sy = y0+yy
			-- 0x100 for half-open mode (don't draw last pixel -- simplifies math)
			tline3d(cbmp, x0,sy,x1,sy, 0,yy/tile_hh,cbmp:width(),yy/tile_hh, nil,nil,0x100)
		end
		]]
		
		-- edge guidelines
		--[[
		line(x0-1, 0, x0-1, 1000, 5)
		line(x1+0, 0, x1+0, 1000, 5)
		line(0, y0-1, 1000, y0-1, 5)
		line(0, y1+0, 1000, y1+0, 5)
	 
		print(pod{yy0, yy1, stat(1)},20,20,7)
		]]
		
		
		
		fillp()


		---------- draw selection

		if (false) then
--		if (csel) then
		
			local sel_scale = min(scale, 0.5)

			while sel_scale < scale and 
				sel_scale * cbmp:width() * tile_w < 128 and
				sel_scale * cbmp:height() * tile_h < 128 do
				sel_scale += 1
			end
			local sel_ww = cbmp:width() * tile_w * sel_scale
			local sel_hh = cbmp:height() * tile_h * sel_scale
		
			-- to do: also update high bits in image to protect
			-- pixels outside of selection from modification
--[[
			if (not csel_outline or sel_ww ~= last_outline_ww) then
				csel_outline = create_outline(csel, sel_ww, sel_hh)
				last_outline_ww = sel_ww
			end
]]
		
			--spr(csel_outline,x0,y0)
			for i=0,63 do
				palt(i,true)
			end
			palt(1,false) palt(2,false)
			
			pal(1,7) pal(2,7)
			
			local cc=(t()*8)%8
			pal(9,  8 + (cc+0)%8)
			pal(17, 8 + (cc+2)%8)
			pal(25, 8 + (cc+4)%8)
			pal(33, 8 + (cc+6)%8)
			
			
			fillp(0xc936936c36c96c93 >> (((time()*15)\1)%4)*16)
			
			-- to do: fix matching
			local qq = 1
			if (sel_scale < scale) qq = 2
			
			--qq = scale / sel_scale
			--pal() fillp()

			pal()

			
--			sspr(csel_outline, 0, 0, _, _, x0-qq, y0-qq, ww+qq*2, hh+qq*2)

			
			
		end

		pal()
		fillp(0xc936936c36c96c93 >> (((time()*15)\1)%4)*16)

		if (ci.layer and ci.layer_x) then
			local sx0 = x0 + ci.layer_x * tile_w * scale
			local sy0 = y0 + ci.layer_y * tile_h * scale
			local sx1 = sx0 + ci.layer:width() * tile_w * scale
			local sy1 = sy0 + ci.layer:height() * tile_h * scale

			rect(sx0-1,sy0-1,sx1,sy1,0x0701)

		elseif (click_x0 and mtool == "select" and msg.mb == 1) then
		
			-- selection in progress
			local mx0 = click_x0
			local my0 = click_y0
			local mx1 = x
			local my1 = y
			if (mx0 > mx1) mx0,mx1 = mx1,mx0
			if (my0 > my1) my0,my1 = my1,my0
			
			local sx0 = x0 + mx0 * tile_w * scale
			local sy0 = y0 + my0 * tile_h * scale
			local sx1 = x0 + (mx1+1) * tile_w * scale
			local sy1 = y0 + (my1+1) * tile_h * scale

			rect(sx0-1,sy0-1,sx1,sy1,0x0701)

		end

		fillp() pal()

		print(string.format("\#0 %3d %3d ",x,y), 12,  self.height-14, 6)
		
		--print(stat(1),10,10,7)

--		if (ci.layer) print("layer: "..pod{ci.layer_x,ci.layer_y,ci.layer:attribs()}, 20, 20,7) -- to do: draw selection. create_outline on demand etc
--		print("mtool: "..mtool,20,30,7)
	end
	
	function el:mousewheel(msg)
	
		local ii = item[1] -- global zoom for now
		if (ii.zoom <= 1) then
			if (msg.wheel_y < 0) ii.zoom /= 2
			if (msg.wheel_y > 0) ii.zoom *= 2
		else
			ii.zoom += msg.wheel_y
		end
		
		local min_scale = 0.25
		local max_scale = 16 -- was 4
		
		-- can zoom out further when wouldn't fit otherwise
		-- if (cbmp:width()  >= self.width ) min_scale = 0.5
		-- if (cbmp:height() >= self.height) min_scale = 0.5		
		
		ii.zoom = mid(min_scale, ii.zoom, max_scale)
		if (ii.zoom >= 1) ii.zoom \= 1
	end
	
	
	return el
end





































:: draw.lua
--[[pod_format="raw",created="2023-10-12 03:26:20",modified="2024-07-18 22:58:53",revision=2264]]
function _draw()
	cls(5)
	-- operations during _update can request a
	-- gui update before it is next draw (avoid flicker)
	if (refresh_gui) then
		generate_gui()
		-- gui:draw_all() expects :update_all() called first on current state of gui
		gui:update_all()
		refresh_gui = false
	end
		
	fillp() pal()
	gui:draw_all()
	
	-- dark gray
	poke4(0x5000+32*4, 0x20202020)
	
	if (custom_palette) then
		poke4(0x5000, get(custom_palette))
	end
	
end


:: gui.lua
--[[pod_format="raw",created="2023-05-11 02:05:16",modified="2024-07-18 22:58:53",revision=3088]]

show_pane = true



 -- update layout without needing to regenerate gui
 -- to do: could also use this for handling changes in display size
 function update_gui_layout()
 	if (not sidebar or not canvas_el) return
 	
 	xt = show_pane and 336 or 480
 	sidebar_x = sidebar_x or sidebar.x
 	sidebar_x = (sidebar_x * 3 + xt) / 4
 	
	if (sidebar_x > xt) then
		sidebar_x = max(xt, sidebar_x - 8)
	else
		sidebar_x = min(xt, sidebar_x + 8)
	end
	
	-- !! instant change -- maybe better (still get toolbar transition!)
	sidebar_x = xt

 	sidebar.x = sidebar_x \ 1
 	sidebar.height = get_display():height()
 
	canvas_el.width = sidebar_x \ 1
	canvas_el.height = get_display():height()
 
	-- send a message to wm asking to undock / dock toolbar
	if show_pane ~= last_show_pane then	
		--send_message(3, {event="dock_toolbar", state = show_pane})
	end
	last_show_pane = show_pane
 end
 

function generate_gui()
	
	gui = create_gui()
	
	-- remove temporary items attached on demand
	layer_name_editor = nil
	field_editor = nil
	
	if (not show_pane) then
		gui:attach(create_canvas{x=0,y=0,width=480,height=get_display():height()})
		return
	end
	
	canvas_el = gui:attach(create_canvas{x=0,y=0,width=336,height=261})
	
	sidebar = gui:attach{x=480-144,y=0,width=150,height=250}
	
	sidebar:attach(create_layer_info{x=8,y=5,width=128,height=24})
	sidebar:attach(create_layer_nav{x=8,y=16,width=128,height=55})
	
	-- a little space above palette for tabs (operation)
	--local pal_el = sidebar:attach(create_palette{x=8,y=14,width=128,height=32})
		
	--sidebar:attach(create_item_info{x=8,y=64,width=128,height=20})
	sidebar:attach(create_item_info{x=8,y=96,width=128,height=24})
	sidebar:attach(create_bank_tabs{x=8+128-48+1,y=116-9,width=48,height=9})
	sidebar:attach(create_nav{x=8,y=116,width=128,height=128})
	sidebar:attach(create_ram_widget{x=88,y=250,width=60,height=10})

	
	---- tools ----
	
	-- ** to do: tool should depend on layer type.
	-- ** e.g. entity picker when layer is entities mode
	
	local tools = {
		"pencil", "rect","fill","stamp","select","pick","pan"
	}
	
	local ww=12
	local yy=75 -- gfx is 50
	for i=0,#tools-1 do
	sidebar:attach(create_tool_button(tools[i+1], 
		10+(i%ww)*14, yy+(i\ww)*14))
	end
	
	
	
	update_gui_layout()


end
local tool_gfx={
pencil="[gfx]08080000700000077700007777700777770070777000700700007770000000000000[/gfx]",
brush="[gfx]08080000077000007700000770000007000007700000077000007700000000000000[/gfx]",
line="[gfx]08080000007000000700000070000007000000700000070000007000000000000000[/gfx]",
--rect="[gfx]08087777777070000070700000707000007070000070700000707777777000000000[/gfx]",
rect= -- alway filled in map editor
--[[pod,pod_type="image"]]unpod("b64:bHo0ABQAAAAXAAAAs3B4dQBDIAgIBGcAAgBQAGcAZ4A="),
pick=
--[[pod,pod_type="image"]]unpod("b64:bHo0ABgAAAAWAAAA8AdweHUAQyAICAQgB2AHsBcgF7AHYAew"),
select="[gfx]08087707077070000070000000007000007000000000700000707707077000000000[/gfx]",
shape="[gfx]08087777777070000070700000707000007070000070700000707777777000000000[/gfx]",
pan="[gfx]08080070700000707070007070700077777070777770077777700077770000000000[/gfx]",
fill="[gfx]08080000700000000700000000700777777770777770700777007000700000000000[/gfx]",
stamp="[gfx]08080077700000777000007770000077700077777770700000707777777000000000[/gfx]",
smudge="[gfx]08080070000000700000007070700077777070777770077777700077770000000000[/gfx]",
sweep="[gfx]08080000700000007000000070000007000000070000777777707070707000000000[/gfx]",
text="[gfx]08087777777077007770777707707700077070770770770070707777777000000000[/gfx]",
scramble="[gfx]08080700070007000700777777707077707077777770070007007700077000000000[/gfx]",
eraser="[gfx]08080007700000777700077777707077777070077700070070000077000000000000[/gfx]",
}
local brush_gfx={
"[gfx]08080000000000000000000000000007000000000000000000000000000000000000[/gfx]",
"[gfx]08080000000000000000000000000007700000077000000000000000000000000000[/gfx]",
"[gfx]08080000000000000000000700000077700000070000000000000000000000000000[/gfx]",
"[gfx]08080000000000000000000770000077770000777700000770000000000000000000[/gfx]",
"[gfx]08080000000000077000007777000777777007777770007777000007700000000000[/gfx]",
"[gfx]08080077770007777770777777777777777777777777777777770777777000777700[/gfx]",
"[gfx]08080000000000000000000000000000000000777700000000000000000000000000[/gfx]",
"[gfx]08080000000000000000000007000000700000070000007000000700000000000000[/gfx]"
}
function create_brush_button(which, x, y)
	local el= {which = which, x = x, y = y, width=12, height = 12}
	
	el.gfx = userdata(brush_gfx[which])
	
	function el:draw()
		rectfill(0,1,self.width-2,self.height-2,0)
		pal(7, self.which == brush.which and 7 or 13)
		spr(self.gfx,2,2)
		pal(7,7)
	end
	
	function el:tap()
		brush.which = self.which
		brush.thickness = self.which-1
	end
	
	return el
end
function create_tool_button(which, x, y)
	local el= {which = which, x = x, y = y, width=12, height = 12}
	
	el.gfx = tool_gfx[which]
	if (type(el.gfx)=="string") el.gfx = userdata(tool_gfx[which])
	
	function el:draw()
	--[[
		line(1,0,9,0,13)
		rectfill(0,1,10,9,13)
		line(1,10,9,10,13)
	]]
		pal(7, which == ctool and 7 or 13)
		spr(self.gfx,2,2)
		pal(7,7)
	end
	
	function el:tap()
		ctool = self.which
		refresh_gui = true
	end
	
	return el
end

-- from gfx.p64
function create_ram_widget(el)
	function el:draw()
		print(string.format("%2.2fmb (%02d%%)",stat(0)/0x100000,stat(0)\167772),0,0,
			stat(0) > 0xe00000 and 14 or 21) -- warn when more than 7/8ths of capacity
	end
	return el
end

:: main.lua
--[[pod_format="raw",created="2023-04-11 02:04:54",modified="2024-07-18 22:58:53",revision=3148]]
--[[
	Picotron Map Editor
]]
include "draw.lua"
include "update.lua"
include "gui.lua"
include "canvas.lua"
include "nav.lua"
include "undo.lua"
-- deleteme
cbmp,cbmp_width,cbmp_height = nil,nil,nil

-- to do: unify with load_working_file
function create_default_maps()
	-- default maps
	bmp = {}
	item = {}
	for i=1,1 do
		item[i] = {
			bmp   = userdata("u16",32,32),
			name = nil, --"layer "..i, -- later: custom names for layers
			extra = nil, -- text. maybe "notes"?
			pan_x = 0,
			pan_y = 0,
			scale = 1,
			tile_w = 16,
			tile_h = 16
		}
		add_undo_stack(item[i])
	end
end

function save_working_file()
	local output = {}
	for i=1,#item do
		local ii=item[i]
		output[i] = {
			name = ii.name,
			bmp = ii.bmp,
			pan_x = ii.pan_x,
			pan_y = ii.pan_y,
			zoom = ii.zoom,
			tile_w = ii.tile_w,
			tile_h = ii.tile_h,
			hidden = ii.hidden
		}
	end
	
	return output
end

function load_working_file(item_1)
	
	item_1 = type(item_1) == "table" and item_1 or {}
	
	-- dev legacy: zero-based layer collection
	if (not item_1[1] and item_1[0]) then
		item_1 = {item_1[0]}
	end
	item = {}

	for i=1,#item_1 do
		if (type(item_1.layer)=="table") item_1 = item_1.layer -- legacy
		item[i] = item_1[i] or {}
		
		local itm = item[i]

		itm.bmp   = itm.bmp or userdata("i16",16,16)
		itm.sel   = itm.sel or userdata("u8", 16,16)
		itm.name  = itm.name or nil
		itm.extra = itm.extra or nil -- text. maybe "notes"?
		itm.pan_x = itm.pan_x or 0
		itm.pan_y = itm.pan_y or 0
		itm.zoom  = itm.zoom or 1
		itm.tile_w = itm.tile_w or 16
		itm.tile_h = itm.tile_h or 16
		itm.hidden = itm.hidden or false
		add_undo_stack(item[i])
	end	
	
	set_current_item(1)
	
end

--[[
	load everything in /ram/cart/gfx
	to do: per bank invalidation
	to do: gfx files relative to map file?
		-- might want to make maps outside of cart context
]]
function load_spritebanks()
--	printh(" -- load_spritebanks() --")
	gfx_ls = ls("/ram/cart/gfx")
	gfx_file = {}
	for i=1,#gfx_ls do
		local fn = gfx_ls[i]
		local num = tonum(string.sub(fn,1,1))
		fn = "/ram/cart/gfx/"..fn 
--		printh("loading "..fn)
		if (num) then
			gfx_file[num] = fn
			local gfx_dat = fetch(fn)
			if (type(gfx_dat == "table") and gfx_dat[0] and gfx_dat[0].bmp) then
				for i=0,#gfx_dat do
					set_spr(num * 256 + i, gfx_dat[i].bmp)
				end
			end
		end
	end
end

function _init()
	
	poke(0x4000,get(fetch"/system/fonts/p8.font"))
	--poke(0x4002,6) -- to do: should be attribute of p8.font
	
	-- default filename is dummy for now
	-- note: saved inside self (gfx.p64) when loaded as cproj
	--create_default_bank()
	window{
		tabbed = true,
		icon = userdata"[gfx]08080000077777770777777707777777000077777770777777707777777000000000[/gfx]"
	}
		
	mkdir("/ram/cart/map")
	
	wrangle_working_file(
		save_working_file,
		load_working_file,
		"/ram/cart/map/0.map" -- default
	)

	load_spritebanks()
	
	set_current_item(1)
	set_current_bank(0)
	set_current_bank_page(0)
	
	generate_gui()
	
	col = 1 -- sprite index
	
	ctool = "pencil"
	mtool = ctool
	if (key"s") mtool = "select"
	
	brush = {
		spacing=1,
		thickness=2,
		which=3,
		pat=0x0
	}
	
	refresh_gui = true
	
end
function set_current_bank_page(i)
	--printh("setting bank: "..i)
	current_bank_page = i
end
function set_current_bank(i, di)

	i = i or current_bank

	if (di) then
		
		local i0 = i
		i += di
		if (not gfx_file[i]) then
			i = (i + di) % 64
			while (not gfx_file[i] and i ~= i0) do
				i = (i + di) % 64
			end
		end
	end
	
	current_bank = i
	refresh_gui = true
end
function set_current_item(i)

	-- to do: remove
	if (#item == 0) then
		create_default_maps()
	end

	assert(#item > 0)
	i = i or current_item
	i = mid(1, i, #item)
	--printh("setting item: "..i)
	current_item = flr(i)  -- want it to be an integer
	ci = item[current_item]
	cbmp = item[current_item].bmp
	cbmp_width, cbmp_height = cbmp:width(), cbmp:height()

	-- selection
	if not item[current_item].sel or
		item[current_item].sel:width()  ~= cbmp_width or
		item[current_item].sel:height() ~= cbmp_height
	then
		item[current_item].sel = userdata("u8", cbmp_width, cbmp_height)
	end
	
	csel = item[current_item].sel
	csel_outline = item[current_item].sel_outline
end

on_event("lost_focus",
	function (msg)
		map_gfx_state = map_gfx_state or fetch"/ram/shared/map_gfx.pod" or {}
		map_gfx_state.current_sprite_index = col
		map_gfx_state.map_proc_id = pid()
		store("/ram/shared/map_gfx.pod", map_gfx_state)
	end
)
on_event("gained_focus",
	function (msg)
		--printh("@@ [map] reloading spritebanks on gaining focus")
		load_spritebanks()

		-- temporary: set tile sizes to sprite0
		local spr0 = get_spr(0)
		if (spr0) then
			for i=1,#item do
				item[i].tile_w, item[i].tile_h = spr0:width(), spr0:height()
			end
		end

		
		map_gfx_state = fetch"/ram/shared/map_gfx.pod"
		if (map_gfx_state) col = map_gfx_state.current_sprite_index

	end
)

on_event("set_palette",
	function(msg)
		if (type(msg.palette) == "userdata") then
			local w, h, type = msg.palette:attribs()
			if (w == 64 and type == "i32") then
				custom_palette = msg.palette
			end
		end
	end
)



:: nav.lua
--[[pod_format="raw",created="2023-10-11 02:18:48",modified="2024-07-18 22:58:53",revision=3942]]
--[[
	navigate sprite bank
	
	to do: pin tabs from multiple sprite banks at once
	(but 4 tabs on the right "0".."3" are always from selected .gfx file)

]]
icons =
{
	-- notes
	"[gfx]08087777770077777700700007007777770070000700777777000777777000000000[/gfx]",
	
	-- scale
	"[gfx]08087070707000000000700000700000000077700070777000007770707000000000[/gfx]",
	
	-- unlock, lock
	lock0="[gfx]08080077700007000700070000000777770007707700077777000000000000000000[/gfx]",
	lock1="[gfx]08080000000000777000070007000777770007707700077777000000000000000000[/gfx]",

	hidden0=unpod("b64:bHo0AB8AAAAhAAAA8wNweHUAQyAICASQJzAHAAcABxACAIAABwAHMCfwAw=="),
	hidden1=unpod("b64:bHo0AA8AAAAOAAAA4HB4dQBDIAgIBPAIZ-AR"),
	
	bucket_cursor=unpod("b64:bHo0AE8AAABPAAAA8gBweHUAQyAVFQTQAfADAQcFAPAr4EEHAcABZwGgAQcBRwGwAQcRJwHAAQcBAAEHAdABBwEQAdABIAHgAQcgBwHgASAB8AEBBwHwAwHwjQ=="),
	add_layer=unpod("b64:bHo0ACAAAAAhAAAA4XB4dQBDIAgIBG0ALQctBADgDUcNAC0HLQAtBy0AbYA="),
	del_layer=unpod("b64:bHo0ACgAAAArAAAA8wVweHUAQyAICAQNRw0AZwAHDScNBwYAQCcNJwAWAIANBw0HDQcNgA=="),

	edit = unpod("b64:bHo0ABkAAAAXAAAA8AhweHUAQyAICASwB1AnMCcwBwAHQBfwBQ=="),
	
	layer_up = unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICATwAwdQJzBHQAfwBA=="),
	layer_down = unpod("b64:bHo0ABYAAAAUAAAA8AVweHUAQyAICATwAwdARzAnUAfwBA=="),
	
}

function make_toggle_button(el)
	local el = el or {}
	el.width = el.width or 7
	el.height = el.height or 7
	el.set = el.set or function() end
	el.get = el.get or function() end
	
	el.cursor = "pointer"
	
	function el:draw()
		local b = el.bmp0
		if (self.get() and el.bmp1) b = el.bmp1
		local col = self.get() and 7 or 13
		pal(7,col)
		spr(b, 0, 0)
		pal()
	end
	
	function el:click()
		el.set(not el.get())
	end
	
	return el
end



function make_operation_button(el)
	local el = el or {}
	el.width = el.width or 7
	el.height = el.height or 7
	
	el.cursor = "pointer"
	
	function el:draw()
		local b = el.bmp0
		local col = 7
		pal(7,col)
		spr(b, 0, 0)
		pal()
	end
	
	return el
end


-- (only need to change width to go from 12x8 -> 24x16)
function resize_map(index, width, height)
	-- note: userdata only takes numbers for sizes, not strings (!)
	if (width) width=tonum(width)
	if (height) height=tonum(height)
	
	local ww = item[index].bmp:width()
	local hh = item[index].bmp:height()
	local aspect = ww / hh
	local ww = tonum(width) or ww
	local hh = tonum(height) or hh
	
	if (lock_aspect) then
		if (not width)  width  = hh * aspect
		if (not height) height = ww / aspect
	else
		width = width or ww
		height = height or hh
	end
	
	if (width < 1 or width > 8192 or
		height < 1 or height > 8192 or
		width * height > 1024*1024) then
		-- to do: error "bad size" or "too big"
		return
	end
		
	local old = item[index].bmp
	local new = userdata("u16", width, height)
	
	blit(old, new, 0,0, 
		new:width()\2 - old:width()\2,
		new:height()\2 - old:height()\2
	)
	
	item[index].bmp = new
	
	refresh_gui = true
	set_current_item()
end

function move_layer(index, dindex)
	local i1 = index + dindex
	if (i1 < 1 or i1 > #item) return
	item[i1],item[index] = item[index],item[i1]
	if (current_item == i1) then
		set_current_item(index)
	elseif current_item == index then
		set_current_item(i1)
	end
	
	refresh_gui = true
end


-- note: normally only need < ~4 layers, so
-- scrollbar would be normally not needed
-- placeholder. will have: layer name, visible, [parent / tree structure]
-- ** each layer has a type that influences ui **
function create_layer_nav(el)

	local item_h = 8
	
	el = gui:new(el)
	function el:draw()
		rectfill(0,0,self.width-1,self.height-1,0)
		local yy = 2
		for i=1,#item do
			local selected = i == current_item
			label = item[i].name or "[layer "..i.."]"
			if (selected and not layer_name_editor) rectfill(4,yy,self.width-5,yy+6,12)
			
			clip(el.sx,el.sy,5+72,1000)
			print(label,5,yy+1, i == 0 and 7 or 6)
			clip()
			spr(item[i].hidden and icons.hidden1 or icons.hidden0,self.width-14,yy)
			spr(icons.edit,self.width-26,yy)
			pal(7,13)
			spr(icons.layer_up,self.width-38,yy)
			spr(icons.layer_down,self.width-48,yy)
			pal(7,7)
			
			yy += item_h
		end
		
	end
	
	function el:click(msg)
		if (layer_name_editor) refresh_gui = true
	end
	
	function el:doubletap(msg)
		-- same as tap on edit button
		msg.mx = self.width-29
		el:tap(msg)
	end
	
	
	function el:tap(msg)
		local index = 1 + (msg.my - 2) \ item_h
		index = mid(1, index, #item)
		if (msg.mx > self.width - 18) then
			item[index].hidden = not item[index].hidden
		elseif (msg.mx > self.width - 30) then
			readtext(true) -- clear input buffer (to do:should attach_text_editor do that?)
			layer_name_editor = el:attach_text_editor{
				x=2, y= 0+ (index-1)*item_h, width=74, height= 9, 
				block_scrolling = true, max_lines = 1,
				key_callback = {
					enter = function () 
						item[index].name = layer_name_editor:get_text()[1]
						layer_name_editor = nil
						refresh_gui = true
					end
				},
				-- block mouse messages from selecting other layers
				click = function() return true end,
				tap = function() return true end
			}
			layer_name_editor:set_text({(item[index].name or "")})
			layer_name_editor:set_keyboard_focus(true)
			layer_name_editor:set_cursor(1000,1)
			window{capture_escapes = true}
			
		elseif (msg.mx > self.width - 42) then
			move_layer(index, -1)
		elseif (msg.mx > self.width - 52) then
			move_layer(index, 1)
		else
			set_current_item(index)
		end
	end

	return el
end

function create_layer_info(el)
	el = gui:new(el)
	
	local xx = 20 + 24
	local yy = 0
	
	-- map width
	el:attach_field
	{
		x=xx,y=yy,width=20,height=7,
		get=function() return item[current_item].bmp:width() end,
		set=function(self,val)
			backup_state()
			resize_map(current_item, val, nil)
		end,
		label="layer size:"
	}
	
	-- toggle aspect lock
	el:attach(make_toggle_button{
		x=xx+21,y=0,
		bmp0=userdata(icons.lock0),
		bmp1=userdata(icons.lock1),
		set=function(val) lock_aspect = val end,
		get=function() return lock_aspect end,
	})
	
	-- map height
	el:attach_field{
		x=xx+29,y=yy,width=20,height=7,
		get=function() return item[current_item].bmp:height() end,
		set=function(self,val) 
			backup_state()
			resize_map(current_item, nil, val)
		end,
		label=""
	}
	
	-- add layer
	el:attach(make_operation_button{
		x=xx+60,y=0,
		bmp0=icons.add_layer,
		tap=function()
			if (#item >= 6) then
				notify("maximum: 6 layers")
				return
			end
			backup_layers()
			--printh(pod(item[current_item].bmp))
			local new_item = {}
			for k,v in pairs(ci) do
				new_item[k] = unpod(pod(v))
			end
			add_undo_stack(new_item)
			new_item.name = nil
			new_item.bmp:clear()
			
			add(item, new_item, current_item+1)
			refresh_gui = true
		end
	})
	
	-- delete layer
	el:attach(make_operation_button{
		x=xx+72,y=0,
		bmp0=icons.del_layer,
		tap=function()
			if (#item > 1) then
				backup_layers()
				deli(item, current_item)
				set_current_item()
			else
				notify("must have at least one layer")
			end
		end
	})
		
	return el	
end


function create_item_info(el)
	el = gui:new(el)
	function el:draw()
		--rect(0,0,self.width-1, self.height-1, 13)
	end
	
	-- preview thumb
	el:attach{
		x=0,y=0,width=16,height=16,
		draw=function(self)
			rectfill(0,0,23,23,0)
			local b = get_spr(col)
			if (b) spr(b,self.width/2 - b:width()/2, self.height/2-b:height()/2)
		end,
		tap=function(self)
			current_bank = col\256
			current_bank_page = (col&0xff)\64
			refresh_gui = true
		end
	}
	
	local xx0 = 20
	local yy  = 0
	local hex_mode = true
		
	-- index (is 16-bit index in map editor)
	-- to do: toggle hex mode / decimal mode
	el:attach{
		x=xx0,y=yy,width=27,height=7,
		draw=function(self)
			local b= item[current_item].bmp
			rectfill(0,0,self.width-1,self.height-1,13)
			local str = hex_mode and
				string.format("0X%04x",col) or
				string.format("%d",col)
			print(str,self.width-1-#str*4,1,7)
		end,
		tap=function(self)
			hex_mode = not hex_mode
		end
	}
	
	-- bank selection placeholder
	-- click to choose file
	-- maybe pin pages / files? 
	-- (create primary set of tabs, where pages are secondary)
	el:attach{
		x=xx0 + 52,y=yy,width=48,height=7,
		draw=function(self)
			local b= item[current_item].bmp
			rectfill(0,0,self.width-1,self.height-1,1)
			
			local gfx_fn = gfx_file[current_bank] or "??"
			
			print(string.format(gfx_fn:basename(),col),2,1,13)
			
		end
	}
	
	el:attach{x=xx0 + 42,y=yy,width=8,height=7,cursor="pointer",
		draw=function(self)
			rectfill(0,0,self.width-1,self.height-1,13) print("<",2,1,7)
		end,
		tap=function(self) set_current_bank(nil, -1) end
	}
	
	el:attach{x=xx0 + 101,y=yy,width=8,height=7,cursor="pointer",
		draw=function(self)
			rectfill(0,0,self.width-1,self.height-1,13) print(">",2,1,7)
		end,
		tap=function(self) set_current_bank(nil, 1) end
	}
	
	return el
end
	
function create_bank_tabs(el)
	el = gui:new(el)
	function el:draw()
		--rect(0,0,self.width-1, self.height-1, 13)
	end
	
	for i=0,3 do
		local y_offs = i == current_bank_page and 0 or 1
		local tab = el:attach({
			x=i*12,y=y_offs,width=11,height=el.height - y_offs,
			index=i,
			draw = function(self)
				local sel = current_bank_page == self.index
				rectfill(0,0,self.width-1, self.height-1, sel and 7 or 6)
				pset(0,0,5)
				line(0,1,1,0,5)
				line(0,2,2,0,5)
				
				pset(self.width-1,0,5)
				
				line(0,self.height-1,self.width-1,self.height-1,13)
				print(self.index,5,1,13)
			end,
			click = function(self)
				set_current_bank_page(self.index, 1)
				refresh_gui = true
			end
			
		})
	end
	
	return el
end

function create_nav(el)
	function el:draw()
		clip()
		rectfill(-1,-1,self.width, self.height, 0)

		for y=0,7 do
			for x=0,7 do
				local scale = 1
				local bmp = get_spr(x + y*8 + current_bank_page*64)
				if (bmp) then
					local ww,hh = bmp:width(), bmp:height()
					-- to do: this makes very thin bmps invisible in preview
					scale = 16 / max(ww,hh)
					if (scale >= 1) then
						scale = scale \ 1
					elseif (scale >= 0.666) then
						scale = 1 -- up to 24x24, still show pixel for pixel
					end
					clip(self.sx + x*16, self.sy + y*16, 16,16)
					sspr(bmp,
						0,0,nil,nil,
						x*16 + 8 - ww * scale/2,
						y*16 + 8 - hh * scale/2,
						ww*scale, hh*scale)
				end
			end
		end
		
	
		if (current_bank == col\256 and current_bank_page == (col&0xff)\64) then
			
			local ii = (col - current_bank_page*64) & 0xff
			local xx = (ii % 8) * 16
			local yy = (ii \ 8) * 16
	
			clip()
			
			rect(xx-2,yy-2,xx+17,yy+17,0)
			rect(xx-1,yy-1,xx+16,yy+16,7)
		end
		
		
	end
	
	-- select sprite
	function el:drag(msg)
		local x = mid(0,msg.mx * 8 \ self.width,7)
		local y = mid(0,msg.my * 8 \ self.height, 7)
		local i = x + y * 8
		col = i + current_bank_page*64 + current_bank*256
	end
	return el
end



:: pal.lua
--[[pod_format="raw",created="2023-05-11 02:05:01",modified="2024-03-06 05:37:16",revision=568,stored="2023-11-28 03:11:19"]]
local pcols = {[0]=
	0,19,3,27,  11,26,10,23,
	1,17,12,28, 18,16,13,29,
	2,30,14,31, 24,8,25,9,
	20,4,21,15, 5,22,6,7,
}

pcols_continuous = {[0] =
	0,20,4,31,15,8,24,2,
	21,5,22,6,7,23,14,30,
	1,16,17,12,28,29,13,18,
	19,3,27,11,26,10,9,25,
}

pcols_identity = {[0] =
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
	16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
}



function create_pal_tabs(el)

	el = gui:new(el)

	function el:draw()
		--rect(0,0,self.width-1, self.height-1, 13)
	end
	
	local swatch_name={[0]="^","^"}
	
	for i=0,1 do
		local y_offs = i == pal_swatch and 0 or 1
		local tab = el:attach({
			x=i*12,y=y_offs,width=11,height=el.height - y_offs,
			index=i,
			draw = function(self)
				local sel = pal_swatch == self.index
				rectfill(0,0,self.width-1, self.height-1, sel and 6 or 13)
				pset(0,0,5)
				line(0,1,1,0,5)
				line(0,2,2,0,5)
				
				pset(self.width-1,0,5)
				
				line(0,self.height-1,self.width-1,self.height-1,13)
				print(swatch_name[self.index],5,1,5)
				
			end,
			
			click = function(self)
				pal_swatch = self.index
				refresh_gui = true
			end
			
		})
	end
	

	
	return el
end



--for i=0,63 do pcols[i]=i end

--[[
pcols[22],pcols[21]=pcols[21],pcols[22]
pcols[16],pcols[17],pcols[18] = pcols[18], pcols[16],pcols[17]
]]

pal_swatch = 1

function create_palette(el)

	-- identity
	for i=0,63 do pcols[i] = i end
	
	if pal_swatch == 1 then
		for i=0,63 do 
			pcols[i] = pcols_continuous[i\2] or 0 
		end
	end
	
	-- to do: adaptive
	local epr = 16
	local ww = el.width / epr
	local hh = el.height / 4
	
	function el:draw()
		clip()
		
		rectfill(0,0,self.width, self.height, 0)
		rectfill(-1,-1,self.width, self.height, 0)
		
		for y=0,64\epr-1 do
			for x=epr-1,0,-1 do
				rectfill(x * ww, y * hh, x * ww + ww-1, y * hh + hh-1, 
				pcols[x + y*epr])
				if (pcols[x + y*epr] == col) then
					local xx = x * ww
					local yy = y * hh
					if (pal_swatch == 0 or x%2 == 0) then
						rect(xx+0,yy+0,xx+ww*(1+pal_swatch)-1,yy+hh-1,7)
						rect(xx+1,yy+1,xx+ww*(1+pal_swatch)-2,yy+hh-2,0)
					end
				end
			end
		end
		
		
	end
	
	function el:drag(msg)
		local xx = msg.mx \ ww
		local yy = msg.my \ hh
		col = pcols[xx + yy * epr] or 0
	end
	
	
	return el
end











:: undo.lua
--[[pod_format="raw",created="2023-10-14 03:29:27",modified="2024-07-18 22:58:53",revision=2062]]
local layers_snapshot = nil
local layer_op = false -- next thing to undo is a layer operation

function add_undo_stack(ii)
	ii.undo_stack = create_undo_stack(undo_save_state, undo_load_state, 0x11, ii)
end
function undo_save_state(ii)
	return {
		ii.bmp:copy(),
		ii.sel and ii.sel:copy(),
		ii.layer0 and ii.layer0:copy(),
		ii.layer and ii.layer:copy(),
		ii.layer_x or 0,
		ii.layer_y or 0,
		ii.pan_x,
		ii.pan_y,
		ii.zoom
	}
end
function undo_load_state(s, ii)
	ii.bmp = s[1] or userdata("u8",16,16)
	ii.sel =   s[2] or nil
	ii.layer0 = s[3] or nil
	ii.layer = s[4] or nil
	ii.layer_x = s[5]
	ii.layer_y = s[6]
	ii.pan_x = s[7] or 0
	ii.pan_y = s[8] or 0
	ii.zoom = s[9] or 1
end

function backup_state()
	local ii = item[current_item]
	local tt0 = stat(1)
	
	ii.undo_stack:checkpoint()

--	printh(string.format("%3.3f",stat(1)-tt0).." // patch size:"..
--		#(ii.undo_stack.undo_stack[#ii.undo_stack.undo_stack]))

	-- invalidate any layer op. can release layers snapshot too
	-- (they could be the same thing)
	layer_op = false
	layers_snapshot = nil
	
end
function undo()
	if (layer_op and layers_snapshot) then
		-- undo delete or add layer
		layer_op = false -- can only undo layer operation once
		item = layers_snapshot
		refresh_gui = true
		set_current_item()
	else
		-- regular undo on a single layer
		local ii = item[current_item]
		ii.undo_stack:undo()
	end
end
function redo()
	local ii = item[current_item]
	ii.undo_stack:redo()
end



function backup_layers()
	layers_snapshot = {}
	for i=1,#item do
		add(layers_snapshot, item[i])
	end
	layer_op = true
end

:: update.lua
--[[pod_format="raw",created="2023-10-10 07:45:26",modified="2024-07-18 22:58:53",revision=2796]]

-- update layout without needing to regenerate gui
 -- to do: could also use this for handling changes in display size
 function update_gui_layout()
 	if (not sidebar or not canvas_el) return
 	
 	xt = show_pane and 336 or 480
 	sidebar_x = sidebar_x or sidebar.x
 	sidebar_x = (sidebar_x * 3 + xt) / 4
 	
	if (sidebar_x > xt) then
		sidebar_x = max(xt, sidebar_x - 8)
	else
		sidebar_x = min(xt, sidebar_x + 8)
	end
	
	-- !! instant change -- maybe better (still get toolbar transition!)
	sidebar_x = xt

 	sidebar.x = sidebar_x \ 1
 	sidebar.height = get_display():height()
 
	canvas_el.width = sidebar_x \ 1
	canvas_el.height = get_display():height()
 
	-- send a message to wm asking to undock / dock toolbar
	if show_pane ~= last_show_pane then	
		--send_message(3, {event="dock_toolbar", state = show_pane})
	end
	last_show_pane = show_pane
 end


function get_selected_region()
	local x0,y0 = 10000, 10000
	local x1,y1 = 0,0
	for y = 0, cbmp_height-1 do
		for x = 0, cbmp_width-1 do
			if (get(csel, x, y) > 0) then
				x0 = min(x0, x) y0 = min(y0, y)
				x1 = max(x1, x) y1 = max(y1, y)
			end 
		end
	end
	if (x0 == 10000) x0,y0,x1,y1 = 0, 0, cbmp_width-1, cbmp_height-1
	
	return x0, y0, x1-x0+1, y1-y0+1
end


function copy_selected_region()
	local x0, y0, ww, hh = get_selected_region()
	local out = userdata("i16", ww, hh)
	--printh(pod{x0,y0, ww,hh})
	blit(cbmp, out, x0, y0, 0, 0)
	return out
end


function move_selection(dx, dy)
	backup_state()
	
	if (not ci.layer) then
		-- just pan (louis instinctively tried this)
		item[1].pan_x += dx * item[1].zoom * 4
		item[1].pan_y += dy * item[1].zoom * 4
		return
	end
	
	blit(ci.layer0, cbmp)
	ci.layer_x += dx
	ci.layer_y += dy
	blit(ci.layer, cbmp, 0, 0, ci.layer_x, ci.layer_y)
	
	-- new selection
	csel:clear()
	local ww, hh = ci.layer:attribs()
	
	set_draw_target(csel)
	rectfill(ci.layer_x, ci.layer_y, ci.layer_x + ww-1, ci.layer_y + hh-1, 1)
	csel_outline = nil -- regenerate
	set_draw_target()
end

 
function clear_selection()
	backup_state()
	if (csel) csel:clear()
	csel_outline = nil -- refresh
	ci.layer, ci.back = nil, nil
end

function select_all()
	backup_state()
	csel:copy(1,true)
	csel_outline = nil -- regenerate	
	local ww,hh = cbmp_width,cbmp_height
	ci.layer = userdata("i16",ww,hh)
	ci.layer_x = 0
	ci.layer_y = 0
	ci.layer0 = cbmp:copy()

	-- same as select tool -- cut out area that will move (all of it)
	ci.layer0:clear() 
	

	blit(cbmp,ci.layer)
	
end

function modify_selection(op)
	backup_state()
	
	local tbmp = ci.layer or cbmp
	local orig = tbmp:copy()
	
	if (op == "flip_x") then
		for x=0, tbmp:width()-1 do
			blit(orig,tbmp,x,0,tbmp:width()-1-x,0,1,tbmp:height())
		end
		tbmp:bxor(0x4000, true)
	end
	
	if (op == "flip_y") then
		for y=0, tbmp:height()-1 do
			blit(orig,tbmp,0,y,0,tbmp:height()-1-y,tbmp:width(),1)
		end
		tbmp:bxor(0x8000, true)
	end
	
	-- layer only -- don't clear whole map with del
	if (ci.layer and op == "clear") then
		ci.layer:clear()
	end
	
	-- update changes
	if (ci.layer) blit(ci.layer, cbmp, 0, 0, ci.layer_x, ci.layer_y)
end



 
 function _update()
 
	-- want to know if editing text at start of frame, so
	-- that can ignore enter keypress (erf) -- messed up checkpointing
	local kfce0 = gui:get_keyboard_focus_element()
 
 	gui:update_all()
	update_gui_layout()
 	set_draw_target()
 	
 	-------------------------------------------------------------
 
 	if (keyp("escape")) then
 		-- get rid of attach-on-demand elements
		refresh_gui = true
		window{capture_escapes = false}	
 	end
 	
  	-- layer name editor (or something else) has/had kbd focus -> ignore other input
 	if (gui:get_keyboard_focus_element() or kfce0) return
	-------------------------------------------------------------
 	
	if keyp("tab") then
		show_pane = not show_pane
		refresh_gui=true
	elseif keyp("enter") then
		clear_selection()
	end
	
	local mag = key("ctrl") and 8 or 1
	if (keyp("left"))  move_selection(-mag, 0)
	if (keyp("right")) move_selection( mag, 0)
	if (keyp("up"))    move_selection( 0,-mag)
	if (keyp("down"))  move_selection( 0, mag)
	
	if (keyp("f")) modify_selection("flip_x")
	if (keyp("v")) modify_selection("flip_y")
	if (keyp("del") or keyp("backspace")) modify_selection("clear")

	
 	-- 
 	if (key("ctrl")) then
 
 	if keyp("c") or keyp("x") then
 		local tbmp = ci.layer or cbmp
 		set_clipboard(pod(tbmp,7,{pod_type="map"}))
 		if keyp("x") then
			backup_state()
			tbmp:clear()
			if (ci.layer) blit(ci.layer, cbmp, 0, 0, ci.layer_x, ci.layer_y)
			notify(string.format("cut %d x %d tiles",tbmp:width(),tbmp:height()))
 		else
			notify(string.format("copied %d x %d tiles",tbmp:width(),tbmp:height()))
		end
	end
	
	if keyp("v") then
		local ct = get_clipboard()
		local bmp1 = nil
		if (sub(ct,1,5) == "[gfx]") then
			bmp1 = userdata(ct)
		else
			bmp1 = unpod(ct)
		end
		if (type(bmp1) == "userdata") then
			backup_state()
			item[current_item].bmp = bmp1
			set_current_item(current_item)
		end
	end
	
	if keyp("z") then
		undo()
		set_current_item(current_item)
		refresh_gui = true
	end
	
	if keyp("y") then
		redo()
		set_current_item(current_item)
		refresh_gui = true
	end
	
	if keyp("a") then
		select_all()
	end
	
	
	end -- ctrl


	
 end
 





































:: workspaces.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTE3LTI2IDE0OjE3OjE2Iixtb2RpZmllZD0iMjAyMy0y
MC0yNiAxNjoyMDo0MSIscmV2aXNpb249NDRdXWx6NAB5AAAAGwEAAPcae3tsb2NhdGlvbj0ibWFp
bi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSwoAE9kcmF3KAADGTIoAG91cGRhdGUqAAMZMyoAP25h
dicAAxk0JwA-Z3VpJwADGTUnAG9jYW52YXMqAAMZNioAT3VuZG8oAAFQeD03
:: .info.pod
b64$LS1bW3BvZCx0aXRsZT0iUGljb3Ryb24gTWFwIEVkaXRvciIsbW9kaWZpZWQ9IjIwMjUtMDQt
MjcgMTY6MDU6MTMiLG5vdGVzPSIiLHN0b3JlZD0iMjAyNC0wNC0wMyAwNjowNDoyOCIsYXV0aG9y
PSJsZXhhbG9mZmxlIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAwMDAxMDEwMTAxMDEw
MTAxMDEwMTAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMDAxMDcwZDBk
MGQwZDBkMGQwZDBkMGQwZDA3MDEwMDAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEw
NzBkMGQwZDA3MDcwNzBkMDcwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMDcwNzA3MGQwNzA3MGQwZDBk
MDcwMTAxMDcwZDBkMGQwNzA3MDcwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDA3MDcw
NzBkMGQwZDA3MDEwMTA3MGQwZDBkMDcwNzBkMDcwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3
MGQwNzA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA2MDcw
ZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDYwMTAxMDYwNjA3MDcwNzA3MDcwNzA3MDcwNzA3MDYwNjAx
MDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDEwNjA2MDYwNjA2MDYwNjA2MDYw
NjAxMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwIikscnVudGltZT04LGNyZWF0
ZWQ9IjIwMjQtMDMtMjkgMTI6Mzk6NTMiLHZlcnNpb249IjAuMWgiLHdvcmtzcGFjZXM9e3tsb2Nh
dGlvbj0ibWFpbi5sdWEjMTQxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkcmF3Lmx1
YSM2Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1cGRhdGUubHVhIzE0NyIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibmF2Lmx1YSMxNzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249Imd1aS5sdWEjNzUiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNhbnZh
cy5sdWEjMjI5Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1bmRvLmx1YSMxOSIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzBiLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9
LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJtYXAv
MC5tYXAiLHdvcmtzcGFjZV9pbmRleD03fX1dXQ==
:: [eoc]
